/**
 * @license
 * Copyright 2010-2022 Ddls.js Authors lo-th
 * SPDX-License-Identifier: MIT
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).DDLS={})}(this,(function(t){"use strict";const e=Math.PI/180,s=180/Math.PI,i=.01,n=1e-4,h=1/0,r=2*Math.PI;var o={view:null,get:function(){return this.view},set:function(t){this.view=t}};const l={id:{segment:0,shape:0,edge:0,face:0,mesh2D:0,object2D:0,vertex:0,graph:0,graphEdge:0,graphNode:0},get:function(t){return this.id[t]++,this.id[t]},reset:function(){this.id={segment:0,shape:0,edge:0,face:0,mesh2D:0,object2D:0,vertex:0,graph:0,graphEdge:0,graphNode:0}}};var a={callback:function(t){console.log(t)},log:function(t){this.callback(t)}};const d=t=>{a.log(t)};class g{constructor(t=0){this.type=t,this.m=new Map}set(t,e){this.m.set(1===this.type?t.id:t,e)}get(t){return this.m.has(1===this.type?t.id:t)?this.m.get(1===this.type?t.id:t):null}remove(t){this.m.delete(1===this.type?t.id:t)}dispose(){this.m.clear()}}const u=(t,e)=>t+Math.floor(Math.random()*(e-t+1)),p=t=>t-2*Math.floor((t+Math.PI)/(2*Math.PI))*Math.PI,c=(t,e)=>Math.sqrt(t*t+e*e),x=(t,e,s)=>Math.abs(t-e)<s,f=(t,e)=>1*t.toFixed(e||3),m=(t,e)=>t*t+e*e,_=t=>Math.floor(t),y=(t,e,s,i)=>{let n,h;t&&(s=t.width,i=t.height,n=document.createElement("canvas"),n.width=s,n.height=i,h=n.getContext("2d"),h.drawImage(t,0,0,s,i),e=h.getImageData(0,0,s,i));const r={bytes:e.data,width:s,height:i};return t&&(h.clearRect(0,0,s,i),n=null,h=null),r};class E{constructor(){this.type=2,this.id=l.get("face"),this.isReal=!1,this.edge=null}setDatas(t,e){this.isReal=void 0===e||e,this.edge=t}dispose(){this.edge=null,this.isReal=!1}}class w{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}transform(t){return t.tranform(this),this}copy(t){return this.x=t.x,this.y=t.y,this}clone(){return new w(this.x,this.y)}sub(t){return this.x-=t.x,this.y-=t.y,this}mul(t){return this.x*=t,this.y*=t,this}add(t){return this.x+=t.x,this.y+=t.y,this}div(t){let e=1/t;return this.x*=e,this.y*=e,this}negate(){return new w(-this.x,-this.y)}transformMat2D(t){let e=this.x,s=this.y,i=t.n;return this.x=i[0]*e+i[2]*s+i[4],this.y=i[1]*e+i[3]*s+i[5],this}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}angular(t){return this.x=Math.cos(t),this.y=Math.sin(t),this}normalize(){const t=this.length();return this.x/=t,this.y/=t,this}distanceTo(t){let e=t.x-this.x,s=t.y-this.y;return Math.sqrt(e*e+s*s)}distanceSquaredTo(t){let e=t.x-this.x,s=t.y-this.y;return e*e+s*s}equals(t){return this.x===t.x&&this.y===t.y}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){return Math.atan2(t.y-this.y,t.x-this.x)}}class C{constructor(){this.type=0,this.id=l.get("vertex"),this.pos=new w,this.fromConstraintSegments=[],this.edge=null,this.isReal=!1}setDatas(t,e){this.isReal=void 0===e||e,this.edge=t}addFromConstraintSegment(t){-1===this.fromConstraintSegments.indexOf(t)&&this.fromConstraintSegments.push(t)}removeFromConstraintSegment(t){const e=this.fromConstraintSegments.indexOf(t);-1!==e&&this.fromConstraintSegments.splice(e,1)}dispose(){this.pos=null,this.edge=null,this.fromConstraintSegments=null}toString(){return"ver_id "+this.id}}class S{constructor(t,e){this.id=l.get("segment"),this.edges=[],this.fromShape=null}addEdge(t){-1===this.edges.indexOf(t)&&-1===this.edges.indexOf(t.oppositeEdge)&&this.edges.push(t)}removeEdge(t){const e=this.edges.indexOf(t);-1===e&&(e=this.edges.indexOf(t.oppositeEdge)),-1!==e&&this.edges.splice(e,1)}dispose(){this.edges=null,this.fromShape=null}toString(){return"seg_id "+this.id}}class F{constructor(){this.type=1,this.id=l.get("edge"),this.fromConstraintSegments=[],this.isConstrained=!1,this.isReal=!1,this.originVertex=null,this.oppositeEdge=null,this.nextLeftEdge=null,this.leftFace=null}get destinationVertex(){return this.oppositeEdge.originVertex}get nextRightEdge(){return this.oppositeEdge.nextLeftEdge.nextLeftEdge.oppositeEdge}get prevRightEdge(){return this.oppositeEdge.nextLeftEdge.oppositeEdge}get prevLeftEdge(){return this.nextLeftEdge.nextLeftEdge}get rotLeftEdge(){return this.nextLeftEdge.nextLeftEdge.oppositeEdge}get rotRightEdge(){return this.oppositeEdge.nextLeftEdge}get rightFace(){return this.oppositeEdge.leftFace}setDatas(t,e,s,i,n,h){this.isConstrained=void 0!==n&&h,this.isReal=void 0===n||n,this.originVertex=t,this.oppositeEdge=e,this.nextLeftEdge=s,this.leftFace=i}getDatas(){return[this.originVertex.pos.x,this.originVertex.pos.y,this.destinationVertex.pos.x,this.destinationVertex.pos.y,this.isConstrained?1:0]}addFromConstraintSegment(t){-1===this.fromConstraintSegments.indexOf(t)&&this.fromConstraintSegments.push(t)}removeFromConstraintSegment(t){const e=this.fromConstraintSegments.indexOf(t);-1!==e&&this.fromConstraintSegments.splice(e,1)}dispose(){this.originVertex=null,this.oppositeEdge=null,this.nextLeftEdge=null,this.leftFace=null,this.fromConstraintSegments=null}toString(){return"edge "+this.originVertex.id+" - "+this.destinationVertex.id}}class V{constructor(){this.id=l.get("shape"),this.segments=[]}dispose(){for(;this.segments.length>0;)this.segments.pop().dispose();this.segments=null}}class P{constructor(t=1,e=0,s=0,i=1,n=0,h=0){this.n=[t||1,e||0,s||0,i||1,n||0,h||0]}identity(){return this.n=[1,0,0,1,0,0],this}translate(t){let e=this.n;return e[4]+=t.x,e[5]+=t.y,this}scale(t){let e=this.n;return e[0]*=t.x,e[1]*=t.y,e[2]*=t.x,e[3]*=t.y,e[4]*=t.x,e[5]*=t.y,this}rotate(t){let e=this.n,s=e[0],i=e[1],n=e[2],h=e[3],r=e[4],o=e[5],l=Math.sin(t),a=Math.cos(t);return e[0]=s*a+i*l,e[1]=-s*l+i*a,e[2]=n*a+h*l,e[3]=-n*l+a*h,e[4]=a*r+l*o,e[5]=a*o-l*r,this}tranform(t){let e=this.n,s=e[0]*t.x+e[2]*t.y+e[4],i=e[1]*t.x+e[3]*t.y+e[5];t.x=s,t.y=i}transformX(t,e){let s=this.n;return s[0]*t+s[2]*e+s[4]}transformY(t,e){let s=this.n;return s[1]*t+s[3]*e+s[5]}concat(t){let e=this.n,s=t.n,i=e[0]*s[0]+e[1]*s[2],n=e[0]*s[1]+e[1]*s[3],h=e[2]*s[0]+e[3]*s[2],r=e[2]*s[1]+e[3]*s[3],o=e[4]*s[0]+e[5]*s[2]+s[4],l=e[4]*s[1]+e[5]*s[3]+s[5];return e[0]=i,e[1]=n,e[2]=h,e[3]=r,e[4]=o,e[5]=l,this}clone(){let t=this.n;return new P(t[0],t[1],t[2],t[3],t[4],t[5])}}class v{constructor(t=1234,e=0,s=1){this.min=e,this.max=s,this.seed=this.currentSeed=t,this.nid=0}getSeed(){return this.seed}setSeed(t){this.seed=this.currentSeed=t}reset(){this.currentSeed=this.seed,this.nid=0}next(){let t=1*this.currentSeed,e=(t*t).toString();for(;e.length<8;)e="0"+e;this.currentSeed=parseInt(e.substr(1,5));let s=Math.round(this.min+this.currentSeed/99999*(this.max-this.min));return 0===this.currentSeed&&(this.currentSeed=this.seed+this.nid),this.nid++,200===this.nid&&this.reset(),s}nextInRange(t,e){return this.min=t,this.max=e,this.next()}shuffle(t){let e,s,i=t.length;for(;i--;)e=this.nextInRange(0,i),s=t[i],t[i]=t[e],t[e]=s}}class b{constructor(){this._fromFace=null,this._nextEdge=null}set fromFace(t){this._fromFace=t,this._nextEdge=this._fromFace.edge}next(){return null!=this._nextEdge?(this._resultEdge=this._nextEdge,this._nextEdge=this._nextEdge.nextLeftEdge,this._nextEdge==this._fromFace.edge&&(this._nextEdge=null)):this._resultEdge=null,this._resultEdge}}//!\\ not used
//!\\ not used
class D{constructor(){this._fromMesh=null,this._currIndex=0}set fromMesh(t){this._fromMesh=t,this._currIndex=0}next(){do{if(!(this._currIndex<this._fromMesh._vertices.length)){this._resultVertex=null;break}this._resultVertex=this._fromMesh._vertices[this._currIndex],this._currIndex++}while(!this._resultVertex.isReal);return this._resultVertex}}//!\\ not used
class L{constructor(){this._fromVertex=null,this._nextEdge=null}set fromVertex(t){this._fromVertex=t,this._nextEdge=this._fromVertex.edge}next(){if(null!=this._nextEdge){do{if(this._resultFace=this._nextEdge.leftFace,this._nextEdge=this._nextEdge.rotLeftEdge,this._nextEdge==this._fromVertex.edge){this._nextEdge=null,this._resultFace.isReal||(this._resultFace=null);break}}while(!this._resultFace.isReal)}else this._resultFace=null;return this._resultFace}}class T{constructor(){this._fromVertex=null,this._nextEdge=null}set fromVertex(t){for(this._fromVertex=t,this._nextEdge=this._fromVertex.edge;!this._nextEdge.isReal;)this._nextEdge=this._nextEdge.rotLeftEdge}next(){if(null!=this._nextEdge){this._resultEdge=this._nextEdge.oppositeEdge;do{if(this._nextEdge=this._nextEdge.rotLeftEdge,this._nextEdge==this._fromVertex.edge){this._nextEdge=null;break}}while(!this._nextEdge.isReal)}else this._resultEdge=null;return this._resultEdge}}class N{constructor(){this.realEdgesOnly=!0,this._fromVertex=null,this._nextEdge=null}set fromVertex(t){if(this._fromVertex=t,this._nextEdge=this._fromVertex.edge,null!=this._nextEdge)for(;this.realEdgesOnly&&!this._nextEdge.isReal;)this._nextEdge=this._nextEdge.rotLeftEdge}next(){if(null!=this._nextEdge){this._resultEdge=this._nextEdge;do{if(this._nextEdge=this._nextEdge.rotLeftEdge,this._nextEdge==this._fromVertex.edge){this._nextEdge=null;break}}while(this.realEdgesOnly&&!this._nextEdge.isReal)}else this._resultEdge=null;return this._resultEdge}}//!\\ not used
const M={__samples:[],__circumcenter:new w,_randGen:null,locatePosition:function(t,e){let s,i,n,r,o;for(null===M._randGen&&(M._randGen=new v),M._randGen.setSeed(_(10*t.x+4*t.y)),M.__samples.splice(0,M.__samples.length),i=_(Math.pow(e._vertices.length,.3333333333333333)),M._randGen.min=0,M._randGen.max=e._vertices.length-1,s=0;s<i;)M.__samples.push(e._vertices[M._randGen.next()]),s++;let l=h,a=null;for(s=0;s<i;)n=M.__samples[s],r=n.pos,o=m(r.x-t.x,r.y-t.y),o<l&&(l=o,a=n),s++;let u=new L;null===a&&d("no closedVertex find ?"),u.fromVertex=a;let p,c=u.next(),x=new g(0),f=new b,y=0,E=0,w=M.isInFace(t,c);for(;x.get(c)||3===w.type;){if(x.set(c,!0),E++,50==E&&d("WALK TAKE MORE THAN 50 LOOP"),1e3==E){d("WALK TAKE MORE THAN 1000 LOOP -> WE ESCAPE"),w={type:3};break}f.fromFace=c;do{if(p=f.next(),null===p)return d("KILL PATH"),null;y=M.getRelativePosition(t,p)}while(1==y||0==y);c=p.rightFace,w=M.isInFace(t,c)}return x.dispose(),w},isCircleIntersectingAnyConstraint:function(t,e,s){if(t.x<=0||t.x>=s.width||t.y<=0||t.y>=s.height)return!0;let i,n=M.locatePosition(t,s);switch(n.type){case 0:i=n.edge.leftFace;break;case 1:i=n.leftFace;break;case 2:i=n;break;case 3:i=null}let h,r,o=e*e;if(h=i.edge.originVertex.pos,r=m(h.x-t.x,h.y-t.y),r<=o)return!0;if(h=i.edge.nextLeftEdge.originVertex.pos,r=m(h.x-t.x,h.y-t.y),r<=o)return!0;if(h=i.edge.nextLeftEdge.nextLeftEdge.originVertex.pos,r=m(h.x-t.x,h.y-t.y),r<=o)return!0;let l,a,d,u=[];u.push(i.edge),u.push(i.edge.nextLeftEdge),u.push(i.edge.nextLeftEdge.nextLeftEdge);let p,c=new g(0);for(;u.length>0;)if(l=u.pop(),c.set(l,!0),a=l.originVertex.pos,d=l.destinationVertex.pos,p=M.intersectionsSegmentCircle(a,d,t,e),p){if(l.isConstrained)return!0;l=l.oppositeEdge.nextLeftEdge,c.get(l)||c.get(l.oppositeEdge)||-1!=u.indexOf(l)||-1!=u.indexOf(l.oppositeEdge)||u.push(l),l=l.nextLeftEdge,c.get(l)||c.get(l.oppositeEdge)||-1!=u.indexOf(l)||-1!=u.indexOf(l.oppositeEdge)||u.push(l)}return!1},getDirection:function(t,e,s){let i=(s.x-t.x)*(e.y-t.y)+(s.y-t.y)*(-e.x+t.x);return 0==i?0:i>0?1:-1},getRelativePosition:function(t,e){return M.getDirection(e.originVertex.pos,e.destinationVertex.pos,t)},getRelativePosition2:function(t,e){return void 0===e?(console.log("error no eUp"),0):M.Orient2d(e.originVertex.pos,e.destinationVertex.pos,t)},Orient2d:function(t,e,s){let i=(t.x-s.x)*(e.y-s.y)-(t.y-s.y)*(e.x-s.x);return i>-1e-4&&i<n?0:i>0?-1:1},isInFace:function(t,e){let s={type:3};if(null===e)return s;let i=e.edge,h=i.nextLeftEdge,r=h.nextLeftEdge;if(M.getRelativePosition(t,i)>=0&&M.getRelativePosition(t,h)>=0&&M.getRelativePosition(t,r)>=0){let o=i.originVertex,l=h.originVertex,a=r.originVertex,d=o.pos.x,g=o.pos.y,u=l.pos.x,p=l.pos.y,c=a.pos.x,x=a.pos.y,f=m(d-t.x,g-t.y),_=m(u-t.x,p-t.y),y=m(c-t.x,x-t.y),E=1/m(u-d,p-g),w=1/m(c-u,x-p),C=1/m(d-c,g-x),S=(t.x-d)*(u-d)+(t.y-g)*(p-g),F=(t.x-u)*(c-u)+(t.y-p)*(x-p),V=(t.x-c)*(d-c)+(t.y-x)*(g-x),P=_-F*F*w<=n,v=y-V*V*C<=n;s=f-S*S*E<=n?v?o:P?l:i:P?v?a:h:v?r:e}return s},clipSegmentByTriangle:function(t,e,s,n,h,r,o){let l=M.getDirection(s,n,t),a=M.getDirection(s,n,e);if(l<=0&&a<=0)return!1;let d=M.getDirection(n,h,t),g=M.getDirection(n,h,e);if(d<=0&&g<=0)return!1;let u=M.getDirection(h,s,t),p=M.getDirection(h,s,e);if(u<=0&&p<=0)return!1;if(l>=0&&d>=0&&u>=0&&a>=0&&g>=0&&p>=0)return r=t.clone(),o=e.clone(),!0;let c=0;return M.intersections2segments(t,e,s,n,r,null)&&c++,0==c?M.intersections2segments(t,e,n,h,r,null)&&c++:M.intersections2segments(t,e,n,h,o,null)&&(-.01>r.x-o.x||r.x-o.x>i||-.01>r.y-o.y||r.y-o.y>i)&&c++,0==c?M.intersections2segments(t,e,h,s,r,null)&&c++:1==c&&M.intersections2segments(t,e,h,s,o,null)&&(-.01>r.x-o.x||r.x-o.x>i||-.01>r.y-o.y||r.y-o.y>i)&&c++,1==c&&(l>=0&&d>=0&&u>=0?o=t.clone():a>=0&&g>=0&&p>=0?o=e.clone():c=0),c>0},isDelaunay:function(t){let e=t.originVertex,s=t.destinationVertex,i=t.nextLeftEdge.destinationVertex,n=t.nextRightEdge.destinationVertex;M.getCircumcenter(i.pos,e.pos,s.pos,M.__circumcenter);let h=(i.pos.x-M.__circumcenter.x)*(i.pos.x-M.__circumcenter.x)+(i.pos.y-M.__circumcenter.y)*(i.pos.y-M.__circumcenter.y);return(n.pos.x-M.__circumcenter.x)*(n.pos.x-M.__circumcenter.x)+(n.pos.y-M.__circumcenter.y)*(n.pos.y-M.__circumcenter.y)>=h},getCircumcenter:function(t,e,s,i){null==i&&(i=new w);let n=.5*(t.x+e.x),h=.5*(t.y+e.y),r=.5*(t.x+s.x),o=.5*(t.y+s.y),l=(n*(t.x-s.x)+(h-o)*(t.y-s.y)+r*(s.x-t.x))/(t.x*(s.y-e.y)+e.x*(t.y-s.y)+s.x*(e.y-t.y));return i.x=n+l*(e.y-t.y),i.y=h-l*(e.x-t.x),i},intersections2segments:function(t,e,s,i,n,h,r){null==r&&(r=!1);let o,l=0,a=0,d=(t.x-e.x)*(s.y-i.y)+(e.y-t.y)*(s.x-i.x);if(0==d)o=!1;else{o=!0;let g=1/d;r&&null==n&&null==h||(l=(t.x*(s.y-i.y)+t.y*(i.x-s.x)+s.x*i.y-s.y*i.x)*g,a=(t.x*(s.y-e.y)+t.y*(e.x-s.x)-e.x*s.y+e.y*s.x)*g,r||0<=l&&l<=1&&0<=a&&a<=1||(o=!1))}return o&&(null!=n&&(n.x=t.x+l*(e.x-t.x),n.y=t.y+l*(e.y-t.y)),null!=h&&h.push(l,a)),o},intersections2edges:function(t,e,s,i,n){return null==n&&(n=!1),M.intersections2segments(t.originVertex.pos,t.destinationVertex.pos,e.originVertex.pos,e.destinationVertex.pos,s,i,n)},isConvex:function(t){let e,s,i=!0;return e=t.nextLeftEdge.oppositeEdge,s=t.nextRightEdge.destinationVertex,-1!=M.getRelativePosition(s.pos,e)?i=!1:(e=t.prevRightEdge,s=t.prevLeftEdge.originVertex,-1!=M.getRelativePosition(s.pos,e)&&(i=!1)),i},projectOrthogonaly:function(t,e){let s=e.originVertex.pos.x,i=e.originVertex.pos.y,n=e.destinationVertex.pos.x,h=e.destinationVertex.pos.y,r=t.x,o=t.y,l=(s*s-s*n-s*r+i*i-i*h-i*o+n*r+h*o)/(s*s-2*s*n+i*i-2*i*h+n*n+h*h);t.x=s+l*(n-s),t.y=i+l*(h-i)},intersections2Circles:function(t,e,s,i,n){let h,r,o,l,a,d,g;return a=m(s.x-t.x,s.y-t.y),d=1/(2*a),(t.x!=s.x||t.y!=s.y)&&a<=(e+i)*(e+i)&&a>=(e-i)*(e-i)&&(g=Math.sqrt(((e+i)*(e+i)-a)*(a-(i-e)*(i-e))),h=s.clone().sub(t).mul(d),r=t.clone().add(s).mul(.5),o=h.clone().mul(e*e-i*i),l=r.clone().add(o),null!=n&&n.push(l.x+h.y*g,l.y-h.x*g,l.x-h.y*g,l.y+h.x*g),!0)},intersectionsSegmentCircle:function(t,e,s,i,n){let h,r,o,l=t.x*t.x,a=t.y*t.y,d=e.y*e.y-2*e.y*t.y+a+e.x*e.x-2*e.x*t.x+l,g=2*t.y*s.y-2*l+2*e.y*t.y-2*a+2*e.x*t.x-2*e.x*s.x+2*t.x*s.x-2*e.y*s.y,u=g*g-4*d*(a+s.y*s.y+s.x*s.x-2*t.y*s.y-2*t.x*s.x+l-i*i);if(u<0)return!1;if(0==u)return r=-g/(2*d),!(r<0||r>1)&&(null!=n&&n.push(t.x+r*(e.x-t.x),t.y+r*(e.y-t.y),r),!0);{h=Math.sqrt(u),r=(-g+h)/(2*d),o=(-g-h)/(2*d);let s=!1;return 0<=r&&r<=1&&(null!=n&&n.push(t.x+r*(e.x-t.x),t.y+r*(e.y-t.y),r),s=!0),0<=o&&o<=1&&(null!=n&&n.push(t.x+o*(e.x-t.x),t.y+o*(e.y-t.y),o),s=!0),s}},tangentsPointToCircle:function(t,e,s,i){let n=t.clone().add(e).mul(.5),h=.5*c(t.x-e.x,t.y-e.y);return M.intersections2Circles(n,h,e,s,i)},tangentsCrossCircleToCircle:function(t,e,s,i){let n=c(e.x-s.x,e.y-s.y),h=.25*n,r=s.clone().sub(e).mul(.25).add(e);if(M.intersections2Circles(e,t,r,h,i)){let t=i[0],h=i[1],r=i[2],o=i[3],l=e.clone().add(s).mul(.5),a=((t-l.x)*(s.y-e.y)+(h-l.y)*(-s.x+e.x))/(n*n),d=2*(l.x+a*(s.y-e.y))-t,g=2*(l.y-a*(s.x-e.x))-h,u=d+r-t,p=o+g-h;return i.push(u,p,d,g),!0}return!1},tangentsParalCircleToCircle:function(t,e,s,i){let n=1/c(e.x-s.x,e.y-s.y),h=e.x+t*(s.y-e.y)*n,r=e.y+t*(-s.x+e.x)*n,o=2*e.x-h,l=2*e.y-r,a=o+s.x-e.x,d=l+s.y-e.y,g=h+s.x-e.x,u=r+s.y-e.y;i.push(h,r,o,l,a,d,g,u)},distanceSquaredPointToSegment:function(t,e,s){let i=m(s.x-e.x,s.y-e.y),n=((t.x-e.x)*(s.x-e.x)+(t.y-e.y)*(s.y-e.y))/i;if(n<0)return m(t.x-e.x,t.y-e.y);if(n<=1){return m(e.x-t.x,e.y-t.y)-n*n*i}return m(t.x-s.x,t.y-s.y)},distanceSquaredVertexToEdge:function(t,e){return M.distanceSquaredPointToSegment(t.pos,e.originVertex.pos,e.destinationVertex.pos)},pathLength:function(t){let e,s,i,n,h,r=0,o=t[0],l=t[1],a=2,d=t.length;for(;a<d;)e=t[a],s=t[a+1],i=e-o,n=s-l,h=c(i,n),r+=h,o=e,l=s,a+=2;return r}};class O{constructor(t,e){this.id=l.get("mesh2D"),this.__objectsUpdateInProgress=!1,this.width=t,this.height=e,this.clipping=!0,this._edges=[],this._faces=[],this._objects=[],this._vertices=[],this._constraintShapes=[],this.constraintShape=null,this.__edgesToCheck=[],this.__centerVertex=null,this.AR_vertex=null,this.AR_edge=null,this.isRedraw=!0}deDuplicEdge(){let t,e,s,i,n,h,r=this._edges;for(e=r.length;e;)for(i=r[--e],s=r[--e],t=e;t;)if(h=r[--t],n=r[--t],s===n&&i===h||s===h&&i===n){r.splice(e,2),r.splice(t,2);break}}clear(t){for(;this._vertices.length>0;)this._vertices.pop().dispose();for(this._vertices=[];this._edges.length>0;)this._edges.pop().dispose();for(this._edges=[];this._faces.length>0;)this._faces.pop().dispose();for(this._faces=[];this._constraintShapes.length>0;)this._constraintShapes.pop().dispose();if(this._constraintShapes=[],!t){for(;this._objects.length>0;)this._objects.pop().dispose();this._objects=[]}this.__edgesToCheck=[],this.__centerVertex=null,this.AR_vertex=null,this.AR_edge=null}dispose(){for(;this._vertices.length>0;)this._vertices.pop().dispose();for(this._vertices=null;this._edges.length>0;)this._edges.pop().dispose();for(this._edges=null;this._faces.length>0;)this._faces.pop().dispose();for(this._faces=null;this._constraintShapes.length>0;)this._constraintShapes.pop().dispose();for(this._constraintShapes=null;this._objects.length>0;)this._objects.pop().dispose();this._objects=null,this.__edgesToCheck=null,this.__centerVertex=null,this.AR_vertex=null,this.AR_edge=null}buildFromRecord(t){let e=t.split(";"),s=e.length,i=0;for(;i<s;)this.insertConstraintSegment(parseFloat(e[i]),parseFloat(e[i+1]),parseFloat(e[i+2]),parseFloat(e[i+3])),i+=4}insertObject(t){null!==t.constraintShape&&this.deleteObject(t);let e,s=new V,i=t.coordinates;t.updateMatrixFromValues();let n=t.matrix||new P,h=new w,r=new w,o=i.length,l=0;for(l=0;l<o;l+=4)h.set(i[l],i[l+1]).transformMat2D(n),r.set(i[l+2],i[l+3]).transformMat2D(n),e=this.insertConstraintSegment(h.x,h.y,r.x,r.y),null!=e&&(e.fromShape=s,s.segments.push(e));this._constraintShapes.push(s),t.constraintShape=s,this.__objectsUpdateInProgress||this._objects.push(t)}deleteObject(t){if(null!==t.constraintShape&&(this.deleteConstraintShape(t.constraintShape),t.constraintShape=null,!this.__objectsUpdateInProgress)){let e=this._objects.indexOf(t);this._objects.splice(e,1)}}updateAll(){this.clear(!0);let t,e=this._objects.length,s=0;for(;e--;)t=this._objects[s],t.build(),this.insertObject(t),s++}updateObjects(){this.__objectsUpdateInProgress=!0;let t,e=this._objects.length,s=0;for(;e--;)t=this._objects[s],t.hasChanged&&(this.deleteObject(t),this.insertObject(t),t.hasChanged=!1),s++;this.__objectsUpdateInProgress=!1}insertConstraintShape(t){let e=new V,s=null,i=t.length,n=0;for(;n<i;)s=this.insertConstraintSegment(t[n],t[n+1],t[n+2],t[n+3]),null!=s&&(s.fromShape=e,e.segments.push(s)),n+=4;return this._constraintShapes.push(e),e}deleteConstraintShape(t){let e=t.segments.length,s=0;for(;e--;)this.deleteConstraintSegment(t.segments[s]),s++;t.dispose(),this._constraintShapes.splice(this._constraintShapes.indexOf(t),1)}insertConstraintSegment(t,e,s,i){let r=t,o=e,l=s,a=i;if(t>this.width&&s>this.width||t<0&&s<0||e>this.height&&i>this.height||e<0&&i<0)return null;{let n=s-t,d=i-e,g=-1/0,u=h;if(0!=n){let e=(0-t)/n,s=(this.width-t)/n;g=Math.max(g,Math.min(e,s)),u=Math.min(u,Math.max(e,s))}if(0!=d){let t=(0-e)/d,s=(this.height-e)/d;g=Math.max(g,Math.min(t,s)),u=Math.min(u,Math.max(t,s))}if(!(u>=g))return null;u<1&&(l=n*u+t,a=d*u+e),g>0&&(r=n*g+t,o=d*g+e)}let g=this.insertVertex(r,o);if(null==g)return null;let u=this.insertVertex(l,a);if(null==u)return null;if(g.id===u.id)return null;let p,c,x=new N,f=new S,m=new F,_=new F;m.setDatas(g,_,null,null,!0,!0),_.setDatas(u,m,null,null,!0,!0);let y,E,C,V=[],P=[],v=[],b={type:3},D=new w,L=!1;for(p=g,b=p;;)if(L=!1,0===b.type){for(p=b,x.fromVertex=p;null!=(c=x.next());){if(c.destinationVertex.id===u.id)return c.isConstrained||(c.isConstrained=!0,c.oppositeEdge.isConstrained=!0),c.addFromConstraintSegment(f),c.oppositeEdge.fromConstraintSegments=c.fromConstraintSegments,g.addFromConstraintSegment(f),u.addFromConstraintSegment(f),f.addEdge(c),f;if(M.distanceSquaredVertexToEdge(c.destinationVertex,m)<=n){c.isConstrained||(c.isConstrained=!0,c.oppositeEdge.isConstrained=!0),c.addFromConstraintSegment(f),c.oppositeEdge.fromConstraintSegments=c.fromConstraintSegments,g.addFromConstraintSegment(f),f.addEdge(c),g=c.destinationVertex,m.originVertex=g,b=g,L=!0;break}}if(L)continue;for(x.fromVertex=p;null!=(c=x.next());)if(c=c.nextLeftEdge,M.intersections2edges(c,m,D)){if(c.isConstrained){for(g=this.splitEdge(c,D.x,D.y),x.fromVertex=p;null!=(c=x.next());)if(c.destinationVertex.id===g.id){c.isConstrained=!0,c.oppositeEdge.isConstrained=!0,c.addFromConstraintSegment(f),c.oppositeEdge.fromConstraintSegments=c.fromConstraintSegments,f.addEdge(c);break}p.addFromConstraintSegment(f),m.originVertex=g,b=g}else V.push(c),P.unshift(c.nextLeftEdge),v.push(c.prevLeftEdge),c=c.oppositeEdge,b=c;break}}else{if(1!==b.type)return d("not finding"),null;if(c=b,y=c.nextLeftEdge,y.destinationVertex.id===u.id)return P.unshift(y.nextLeftEdge),v.push(y),E=new F,C=new F,E.setDatas(g,C,null,null,!0,!0),C.setDatas(u,E,null,null,!0,!0),P.push(E),v.push(C),this.insertNewConstrainedEdge(f,E,V,P,v),f;if(M.distanceSquaredVertexToEdge(y.destinationVertex,m)<=n)P.unshift(y.nextLeftEdge),v.push(y),E=new F,C=new F,E.setDatas(g,C,null,null,!0,!0),C.setDatas(y.destinationVertex,E,null,null,!0,!0),P.push(E),v.push(C),this.insertNewConstrainedEdge(f,E,V,P,v),V.splice(0,V.length),P.splice(0,P.length),v.splice(0,v.length),g=y.destinationVertex,m.originVertex=g,b=g;else if(M.intersections2edges(y,m,D))if(y.isConstrained){for(p=this.splitEdge(y,D.x,D.y),x.fromVertex=p;null!=(c=x.next());)c.destinationVertex==P[0].originVertex&&P.unshift(c),c.destinationVertex==v[v.length-1].destinationVertex&&v.push(c.oppositeEdge);E=new F,C=new F,E.setDatas(g,C,null,null,!0,!0),C.setDatas(p,E,null,null,!0,!0),P.push(E),v.push(C),this.insertNewConstrainedEdge(f,E,V,P,v),V.splice(0,V.length),P.splice(0,P.length),v.splice(0,v.length),g=p,m.originVertex=g,b=g}else V.push(y),P.unshift(y.nextLeftEdge),c=y.oppositeEdge,b=c;else if(y=y.nextLeftEdge,M.intersections2edges(y,m,D),y.isConstrained){for(p=this.splitEdge(y,D.x,D.y),x.fromVertex=p;null!=(c=x.next());)c.destinationVertex.id===P[0].originVertex.id&&P.unshift(c),c.destinationVertex.id===v[v.length-1].destinationVertex.id&&v.push(c.oppositeEdge);E=new F,C=new F,E.setDatas(g,C,null,null,!0,!0),C.setDatas(p,E,null,null,!0,!0),P.push(E),v.push(C),this.insertNewConstrainedEdge(f,E,V,P,v),V.splice(0,V.length),P.splice(0,P.length),v.splice(0,v.length),g=p,m.originVertex=g,b=g}else V.push(y),v.push(y.prevLeftEdge),c=y.oppositeEdge,b=c}}insertNewConstrainedEdge(t,e,s,i,n){this._edges.push(e),this._edges.push(e.oppositeEdge),e.addFromConstraintSegment(t),e.oppositeEdge.fromConstraintSegments=e.fromConstraintSegments,t.addEdge(e),e.originVertex.addFromConstraintSegment(t),e.destinationVertex.addFromConstraintSegment(t),this.untriangulate(s),this.triangulate(i,!0),this.triangulate(n,!0)}deleteConstraintSegment(t){let e,s=[],i=null,n=t.edges.length,h=0;for(;h<n;)i=t.edges[h],i.removeFromConstraintSegment(t),0==i.fromConstraintSegments.length&&(i.isConstrained=!1,i.oppositeEdge.isConstrained=!1),e=i.originVertex,e.removeFromConstraintSegment(t),s.push(e),h++;for(e=i.destinationVertex,e.removeFromConstraintSegment(t),s.push(e),n=s.length,h=0;h<n;)this.deleteVertex(s[h]),h++;t.dispose()}check(){let t=this._edges.length,e=0;for(;e<t;){if(null==this._edges[e].nextLeftEdge)return void d("!!! missing nextLeftEdge");e++}d("check OK")}insertVertex(t,e){if(t<0||e<0||t>this.width||e>this.height)return null;this.__edgesToCheck.splice(0,this.__edgesToCheck.length);let s=M.locatePosition(new w(t,e),this),i=null;switch(s.type){case 0:i=s;break;case 1:let n=s;i=this.splitEdge(n,t,e);break;case 2:let h=s;i=this.splitFace(h,t,e)}return this.restoreAsDelaunay(),i}flipEdge(t){let e=t,s=t.oppositeEdge,i=new F,n=new F,h=e.nextLeftEdge,r=h.nextLeftEdge,o=s.nextLeftEdge,l=o.nextLeftEdge,a=e.originVertex,d=s.originVertex,g=r.originVertex,u=l.originVertex,p=e.leftFace,c=s.leftFace,x=new E,f=new E;return this._edges.push(i),this._edges.push(n),this._faces.push(f),this._faces.push(x),i.setDatas(g,n,l,f,t.isReal,t.isConstrained),n.setDatas(u,i,r,x,t.isReal,t.isConstrained),f.setDatas(i),x.setDatas(n),d.edge.id===s.id&&d.setDatas(h),a.edge.id===e.id&&a.setDatas(o),h.nextLeftEdge=i,h.leftFace=f,r.nextLeftEdge=o,r.leftFace=x,o.nextLeftEdge=n,o.leftFace=x,l.nextLeftEdge=h,l.leftFace=f,this._edges.splice(this._edges.indexOf(e),1),this._edges.splice(this._edges.indexOf(s),1),e.dispose(),s.dispose(),this._faces.splice(this._faces.indexOf(p),1),this._faces.splice(this._faces.indexOf(c),1),p.dispose(),c.dispose(),n}splitEdge(t,e,s){this.__edgesToCheck.splice(0,this.__edgesToCheck.length);let i=t,h=i.oppositeEdge,r=i.nextLeftEdge,o=r.nextLeftEdge,l=h.nextLeftEdge,a=l.nextLeftEdge,d=o.originVertex,g=i.originVertex,u=a.originVertex,p=h.originVertex,c=i.leftFace,x=h.leftFace;if((g.pos.x-e)*(g.pos.x-e)+(g.pos.y-s)*(g.pos.y-s)<=n)return g;if((p.pos.x-e)*(p.pos.x-e)+(p.pos.y-s)*(p.pos.y-s)<=n)return p;let f=new C,m=new F,_=new F,y=new F,w=new F,S=new F,V=new F,P=new F,v=new F,b=new E,D=new E,L=new E,T=new E;if(this._vertices.push(f),this._edges.push(_),this._edges.push(m),this._edges.push(V),this._edges.push(S),this._edges.push(w),this._edges.push(y),this._edges.push(v),this._edges.push(P),this._faces.push(T),this._faces.push(L),this._faces.push(D),this._faces.push(b),f.setDatas(c.isReal?_:w),f.pos.x=e,f.pos.y=s,M.projectOrthogonaly(f.pos,i),_.setDatas(f,m,o,b,c.isReal),m.setDatas(d,_,v,T,c.isReal),V.setDatas(f,S,l,D,t.isReal,t.isConstrained),S.setDatas(g,V,_,b,t.isReal,t.isConstrained),w.setDatas(f,y,a,L,x.isReal),y.setDatas(u,w,V,D,x.isReal),v.setDatas(f,P,r,T,t.isReal,t.isConstrained),P.setDatas(p,v,w,L,t.isReal,t.isConstrained),b.setDatas(_,c.isReal),D.setDatas(V,x.isReal),L.setDatas(w,x.isReal),T.setDatas(v,c.isReal),g.edge.id===i.id&&g.setDatas(S),p.edge.id===h.id&&p.setDatas(P),o.nextLeftEdge=S,o.leftFace=b,l.nextLeftEdge=y,l.leftFace=D,a.nextLeftEdge=P,a.leftFace=L,r.nextLeftEdge=m,r.leftFace=T,i.isConstrained){let t,e,s=i.fromConstraintSegments;S.fromConstraintSegments=s.slice(0),V.fromConstraintSegments=S.fromConstraintSegments,v.fromConstraintSegments=s.slice(0),P.fromConstraintSegments=v.fromConstraintSegments;let n=i.fromConstraintSegments.length,r=0;for(;r<n;)t=i.fromConstraintSegments[r].edges,e=t.indexOf(i),-1!=e?t.splice(e,1,S,v):t.splice(t.indexOf(h),1,P,V),r++;f.fromConstraintSegments=s.slice(0)}return this._edges.splice(this._edges.indexOf(i),1),this._edges.splice(this._edges.indexOf(h),1),i.dispose(),h.dispose(),this._faces.splice(this._faces.indexOf(c),1),this._faces.splice(this._faces.indexOf(x),1),c.dispose(),x.dispose(),this.__centerVertex=f,this.__edgesToCheck.push(o),this.__edgesToCheck.push(l),this.__edgesToCheck.push(a),this.__edgesToCheck.push(r),f}splitFace(t,e,s){this.__edgesToCheck.splice(0,this.__edgesToCheck.length);let i=t.edge,n=i.nextLeftEdge,h=n.nextLeftEdge,r=i.originVertex,o=n.originVertex,l=h.originVertex,a=new C,d=new F,g=new F,u=new F,p=new F,c=new F,x=new F,f=new E,m=new E,_=new E;return this._vertices.push(a),this._edges.push(d),this._edges.push(g),this._edges.push(u),this._edges.push(p),this._edges.push(c),this._edges.push(x),this._faces.push(f),this._faces.push(m),this._faces.push(_),a.setDatas(g),a.pos.x=e,a.pos.y=s,d.setDatas(r,g,x,_),g.setDatas(a,d,i,f),u.setDatas(o,p,g,f),p.setDatas(a,u,n,m),c.setDatas(l,x,p,m),x.setDatas(a,c,h,_),f.setDatas(g),m.setDatas(p),_.setDatas(x),i.nextLeftEdge=u,i.leftFace=f,n.nextLeftEdge=c,n.leftFace=m,h.nextLeftEdge=d,h.leftFace=_,this._faces.splice(this._faces.indexOf(t),1),t.dispose(),this.__centerVertex=a,this.__edgesToCheck.push(i),this.__edgesToCheck.push(n),this.__edgesToCheck.push(h),a}restoreAsDelaunay(){let t;for(;this.__edgesToCheck.length>0;)t=this.__edgesToCheck.shift(),!t.isReal||t.isConstrained||M.isDelaunay(t)||(t.nextLeftEdge.destinationVertex.id===this.__centerVertex.id?(this.__edgesToCheck.push(t.nextRightEdge),this.__edgesToCheck.push(t.prevRightEdge)):(this.__edgesToCheck.push(t.nextLeftEdge),this.__edgesToCheck.push(t.prevLeftEdge)),this.flipEdge(t))}deleteVertex(t){let e,s,i=new N;i.fromVertex=t,i.realEdgesOnly=!1;let n=[];e=0==t.fromConstraintSegments.length;let h,r=[],o=!1,l=!1,a=[],d=[];if(e)for(;null!=(s=i.next());)n.push(s),r.push(s.nextLeftEdge);else{let e,h=0,r=t.fromConstraintSegments.length;for(;h<r;){let s=h++;if(e=t.fromConstraintSegments[s].edges,e[0].originVertex.id===t.id||e[e.length-1].destinationVertex.id===t.id)return!1}let g=0;for(;null!=(s=i.next());)if(n.push(s),s.isConstrained&&(g++,g>2))return!1;a=[],d=[];let u=null,p=null,c=new F,x=new F;this._edges.push(c),this._edges.push(x);let f,m=0,_=n.length;for(;m<_;){s=n[m++],s.isConstrained?null==u?(x.setDatas(s.destinationVertex,c,null,null,!0,!0),a.push(c),a.push(s.nextLeftEdge),d.push(x),u=s):null==p&&(c.setDatas(s.destinationVertex,x,null,null,!0,!0),d.push(s.nextLeftEdge),p=s):null==u?d.push(s.nextLeftEdge):null==p?a.push(s.nextLeftEdge):d.push(s.nextLeftEdge)}o=u.leftFace.isReal,l=p.leftFace.isReal,c.fromConstraintSegments=u.fromConstraintSegments.slice(0),x.fromConstraintSegments=c.fromConstraintSegments;let y=0,E=t.fromConstraintSegments.length;for(;y<E;){let s=y++;e=t.fromConstraintSegments[s].edges,f=e.indexOf(u),-1!=f?e.splice(f-1,2,c):e.splice(e.indexOf(p)-1,2,x)}}let g=0,u=n.length;for(;g<u;){s=n[g++],h=s.leftFace,this._faces.splice(this._faces.indexOf(h),1),h.dispose(),s.destinationVertex.edge=s.nextLeftEdge,this._edges.splice(this._edges.indexOf(s.oppositeEdge),1),s.oppositeEdge.dispose(),this._edges.splice(this._edges.indexOf(s),1),s.dispose()}return this._vertices.splice(this._vertices.indexOf(t),1),t.dispose(),e?this.triangulate(r,!0):(this.triangulate(a,o),this.triangulate(d,l)),!0}untriangulate(t){let e,s=new g(1),i=0,n=t.length;for(;i<n;){let n=i++;e=t[n],null==s.get(e.originVertex)&&(e.originVertex.edge=e.prevLeftEdge.oppositeEdge,s.set(e.originVertex,!0)),null==s.get(e.destinationVertex)&&(e.destinationVertex.edge=e.nextLeftEdge,s.set(e.destinationVertex,!0)),this._faces.splice(this._faces.indexOf(e.leftFace),1),e.leftFace.dispose(),n==t.length-1&&(this._faces.splice(this._faces.indexOf(e.rightFace),1),e.rightFace.dispose())}s.dispose();let h=0,r=t.length;for(;h<r;){e=t[h++],this._edges.splice(this._edges.indexOf(e.oppositeEdge),1),this._edges.splice(this._edges.indexOf(e),1),e.oppositeEdge.dispose(),e.dispose()}}triangulate(t,e){if(t.length<2)d("BREAK ! the hole has less than 2 edges");else if(2!==t.length)if(3===t.length){let s=new E;s.setDatas(t[0],e),this._faces.push(s),t[0].leftFace=s,t[1].leftFace=s,t[2].leftFace=s,t[0].nextLeftEdge=t[1],t[1].nextLeftEdge=t[2],t[2].nextLeftEdge=t[0]}else{let s,i,h=t[0],r=h.originVertex,o=h.destinationVertex,l=new w,a=0,g=0,u=!1,p=0,c=2,x=t.length;for(;c<x;){let e=c++;if(s=t[e].originVertex,1==M.getRelativePosition2(s.pos,h)){p=e,u=!0,M.getCircumcenter(r.pos,o.pos,s.pos,l),a=m(r.pos.x-l.x,r.pos.y-l.y),a-=n;let h=2,d=t.length;for(;h<d;){let s=h++;if(s!=e&&(i=t[s].originVertex,g=m(i.pos.x-l.x,i.pos.y-l.y),g<a)){u=!1;break}}if(u)break}}u||(d("NO DELAUNAY FOUND"),p=2);let f,_,y,E,C,S,V=[];p<t.length-1&&(f=new F,_=new F,this._edges.push(f,_),f.setDatas(r,_,null,null,e,!1),_.setDatas(t[p].originVertex,f,null,null,e,!1),C=t.slice(p),C.push(f),this.triangulate(C,e)),p>2&&(y=new F,E=new F,this._edges.push(y,E),y.setDatas(t[1].originVertex,E,null,null,e,!1),E.setDatas(t[p].originVertex,y,null,null,e,!1),S=t.slice(1,p),S.push(E),this.triangulate(S,e)),2===p?V.push(h,t[1],_):p===t.length-1?V.push(h,y,t[p]):V.push(h,y,_),this.triangulate(V,e)}else d("BREAK ! the hole has only 2 edges")}findPositionFromBounds(t,e){return t<=0?e<=0?1:e>=this.height?7:8:t>=this.width?e<=0?3:e>=this.height?5:4:e<=0?2:e>=this.height?6:0}compute_Data(){let t,e;this.AR_vertex=[],this.AR_edge=[];let s=new D;s.fromMesh=this;let i=new T,n=new g(1);for(;null!=(t=s.next());)if(n.set(t,!0),this.vertexIsInsideAABB(t,this))for(this.AR_vertex.push(t.pos.x,t.pos.y),i.fromVertex=t;null!=(e=i.next());)n.get(e.originVertex)||(this.AR_edge=this.AR_edge.concat(e.getDatas()));n.dispose()}vertexIsInsideAABB(t,e){return!(t.pos.x<0||t.pos.x>e.width||t.pos.y<0||t.pos.y>e.height)}}class R extends O{constructor(t=10,e=10){super(t,e),this.w=t,this.h=e;const s=[],i=[],n=[],h=[];let r=4;for(;r--;)n.push(new E),s.push(new C),h.push(new S),i.push(new F,new F,new F);const o=new V,l=10;s[0].pos.set(-10,-10),s[1].pos.set(t+l,-10),s[2].pos.set(t+l,e+l),s[3].pos.set(-10,e+l),s[0].setDatas(i[0]),s[1].setDatas(i[2]),s[2].setDatas(i[4]),s[3].setDatas(i[6]),i[0].setDatas(s[0],i[1],i[2],n[3],!0,!0),i[1].setDatas(s[1],i[0],i[7],n[0],!0,!0),i[2].setDatas(s[1],i[3],i[11],n[3],!0,!0),i[3].setDatas(s[2],i[2],i[8],n[1],!0,!0),i[4].setDatas(s[2],i[5],i[6],n[2],!0,!0),i[5].setDatas(s[3],i[4],i[3],n[1],!0,!0),i[6].setDatas(s[3],i[7],i[10],n[2],!0,!0),i[7].setDatas(s[0],i[6],i[9],n[0],!0,!0),i[8].setDatas(s[1],i[9],i[5],n[1],!0,!1),i[9].setDatas(s[3],i[8],i[1],n[0],!0,!1),i[10].setDatas(s[0],i[11],i[4],n[2],!1,!1),i[11].setDatas(s[2],i[10],i[0],n[3],!1,!1),n[0].setDatas(i[9],!0),n[1].setDatas(i[8],!0),n[2].setDatas(i[4],!1),n[3].setDatas(i[2],!1),s[0].fromConstraintSegments.push(h[0],h[3]),s[1].fromConstraintSegments.push(h[0],h[1]),s[2].fromConstraintSegments.push(h[1],h[2]),s[3].fromConstraintSegments.push(h[2],h[3]),i[0].fromConstraintSegments.push(h[0]),i[1].fromConstraintSegments.push(h[0]),i[2].fromConstraintSegments.push(h[1]),i[3].fromConstraintSegments.push(h[1]),i[4].fromConstraintSegments.push(h[2]),i[5].fromConstraintSegments.push(h[2]),i[6].fromConstraintSegments.push(h[3]),i[7].fromConstraintSegments.push(h[3]),h[0].edges.push(i[0]),h[1].edges.push(i[2]),h[2].edges.push(i[4]),h[3].edges.push(i[6]),h[0].fromShape=o,h[1].fromShape=o,h[2].fromShape=o,h[3].fromShape=o,o.segments.push(h[0],h[1],h[2],h[3]),this.boundShape=o,this._vertices=s,this._edges=i,this._faces=n,this.build()}build(){this._constraintShapes.push(this.boundShape),this.clipping=!1,this.insertConstraintShape([0,0,this.w,0,this.w,0,this.w,this.h,this.w,this.h,0,this.h,0,this.h,0,0]),this.clipping=!0}}class k{constructor(){this.id=l.get("graph"),this.edge=null,this.node=null}dispose(){for(;null!==this.node;)this.deleteNode(this.node)}insertNode(){let t=new j;return null!=this.node&&(t.next=this.node,this.node.prev=t),this.node=t,t}deleteNode(t){for(;null!=t.outgoingEdge;)null!=t.outgoingEdge.oppositeEdge&&this.deleteEdge(t.outgoingEdge.oppositeEdge),this.deleteEdge(t.outgoingEdge);let e,s=this.node;for(;null!=s;)e=s.successorNodes.get(t),null!=e&&this.deleteEdge(e),s=s.next;this.node==t?null!=t.next?(t.next.prev=null,this.node=t.next):this.node=null:null!=t.next?(t.prev.next=t.next,t.next.prev=t.prev):t.prev.next=null,t.dispose()}insertEdge(t,e){if(null!=t.successorNodes.get(e))return null;let s=new A;null!=this.edge&&(this.edge.prev=s,s.next=this.edge),this.edge=s,s.sourceNode=t,s.destinationNode=e,t.successorNodes.set(e,s),null!=t.outgoingEdge?(t.outgoingEdge.rotPrevEdge=s,s.rotNextEdge=t.outgoingEdge,t.outgoingEdge=s):t.outgoingEdge=s;let i=e.successorNodes.get(t);return null!==i&&(s.oppositeEdge=i,i.oppositeEdge=s),s}deleteEdge(t){this.edge==t?null!=t.next?(t.next.prev=null,this.edge=t.next):this.edge=null:null!=t.next?(t.prev.next=t.next,t.next.prev=t.prev):t.prev.next=null,t.sourceNode.outgoingEdge==t?null!=t.rotNextEdge?(t.rotNextEdge.rotPrevEdge=null,t.sourceNode.outgoingEdge=t.rotNextEdge):t.sourceNode.outgoingEdge=null:null!=t.rotNextEdge?(t.rotPrevEdge.rotNextEdge=t.rotNextEdge,t.rotNextEdge.rotPrevEdge=t.rotPrevEdge):t.rotPrevEdge.rotNextEdge=null,t.dispose()}}class A{constructor(){this.id=l.get("graphEdge"),this.next=null,this.prev=null,this.rotPrevEdge=null,this.rotNextEdge=null,this.oppositeEdge=null,this.sourceNode=null,this.destinationNode=null,this.data=null}dispose(){this.next=null,this.prev=null,this.rotPrevEdge=null,this.rotNextEdge=null,this.oppositeEdge=null,this.sourceNode=null,this.destinationNode=null,this.data=null}}class j{constructor(){this.id=l.get("graphNode"),this.successorNodes=new g(1),this.prev=null,this.next=null,this.outgoingEdge=null,this.data=null}dispose(){this.successorNodes.dispose(),this.prev=null,this.next=null,this.outgoingEdge=null,this.successorNodes=null,this.data=null}}function I(){}function q(){}const W={color:{r:255,g:255,b:255},nearly:50,maxDistance:1,setColor:function(t){W.color=t},setNearly:function(t){W.nearly=t},buildShapes:function(t){let e=[],s=new g(2),i=t.height-1,n=t.width-1;for(let h=1;h<i;h++)for(let i=0;i<n;i++)W.getWhite(t,i,h)&&!W.getWhite(t,i+1,h)&&(s.get(i+1+"_"+h)||e.push(W.buildShape(t,h,i+1,s)));return s.dispose(),e},getWhite:function(t,e,s){let i=!1,n=t.bytes,h=t.width,r=W.color,o=W.nearly,l=e+s*h<<2;return void 0!==r.r&&x(n[l],r.r,o)&&(i=!0),void 0!==r.g&&x(n[l+1],r.g,o)&&(i=!0),void 0!==r.b&&x(n[l+2],r.b,o)&&(i=!0),void 0!==r.a&&x(n[l+3],r.a,o)&&(i=!0),i},buildShape:function(t,e,s,i){let n=s,h=e,r=[n,h];i.set(n+"_"+h,!0),t.width,t.height;let o,l,a=new w(0,1),d=new w,g=-1;for(;!(o=e+a.x+a.y,l=s+a.x-a.y,W.getWhite(t,l,o)?(o=e+a.y,l=s+a.x,W.getWhite(t,l,o)?(o=e,l=s,d.x=a.y,d.y=-a.x):(d.x=a.x,d.y=a.y)):(d.x=-a.y,d.y=a.x),n+=a.x,h+=a.y,n===r[0]&&h===r[1]||(r.push(n),r.push(h),i.set(n+"_"+h,!0),e=o,s=l,a.x=d.x,a.y=d.y,g--,0===g)););return r},buildGraph:function(t){let e,s,i,n,h,r,o,l=0,a=new k;for(;l<t.length;)e=a.insertNode(),e.data=new q,e.data.index=l,e.data.point=new w(t[l],t[l+1]),l+=2;let d,g,u=!1;for(s=a.node;null!=s;){for(i=null!=s.next?s.next:a.node;i!=s;){for(u=!0,n=null!=s.next?s.next:a.node,o=2,r=0;n!=i;){if(h=M.distanceSquaredPointToSegment(n.data.point,s.data.point,i.data.point),h<0&&(h=0),h>=W.maxDistance){u=!1;break}o++,r+=h,n=null!=n.next?n.next:a.node}if(!u)break;d=a.insertEdge(s,i),g=new I,g.sumDistancesSquared=r,g.length=s.data.point.distanceTo(i.data.point),g.nodesCount=o,d.data=g,i=null!=i.next?i.next:a.node}s=s.next}return a},buildPolygon:function(t){let e,s,i,n,h,r,o=[],l=2147483647,a=null,d=t.node;for(;d.data.index<l;){for(l=d.data.index,o.push(d.data.point.x),o.push(d.data.point.y),r=0,n=d.outgoingEdge;null!=n;)h=n.data.nodesCount-n.data.length*Math.sqrt(n.data.sumDistancesSquared/n.data.nodesCount),h>r&&(r=h,a=n),n=n.rotNextEdge;d=a.destinationNode}return e=new w(o[o.length-2],o[o.length-1]),s=new w(o[0],o[1]),i=new w(o[2],o[3]),0===M.getDirection(e,s,i)&&(o.shift(),o.shift()),o}},B=(t,e=1)=>{e=e||1;let s=t.length;if(s<=4)return[].concat(t);let i=t[0],n=t[1],h=t[s-2],r=t[s-1],o=-1,l=0,a=1,d=s>>1;for(;a<d;){let e=a++,s=M.distanceSquaredPointToSegment(new w(t[e<<1],t[1+(e<<1)]),new w(i,n),new w(h,r));s>l&&(l=s,o=e)}if(l>e*e){let s=t.slice(0,2+(o<<1)),i=t.slice(o<<1),n=B(s,e),h=B(i,e);return n.slice(0,n.length-2).concat(h)}return[i,n,h,r]};class G{constructor(){this.fromFace=null,this.toFace=null,this.curFace=null,this.iterEdge=new b,this.mesh=null,this._radius=0,this.radiusSquared=0,this.diameter=0,this.diameterSquared=0}get radius(){return this._radius}set radius(t){this._radius=t,this.radiusSquared=this._radius*this._radius,this.diameter=2*this._radius,this.diameterSquared=this.diameter*this.diameter}dispose(){this.mesh=null,this.closedFaces.dispose(),this.openedFaces.dispose(),this.entryEdges.dispose(),this.predecessor.dispose(),this.entryX.dispose(),this.entryY.dispose(),this.scoreF.dispose(),this.scoreG.dispose(),this.scoreH.dispose(),this.sortedOpenedFaces=null,this.closedFaces=null,this.openedFaces=null,this.entryEdges=null,this.entryX=null,this.entryY=null,this.scoreF=null,this.scoreG=null,this.scoreH=null,this.predecessor=null}findPath(t,e,s,i){let n;if(this.sortedOpenedFaces=[],this.closedFaces=new g(1),this.openedFaces=new g(1),this.entryEdges=new g(1),this.predecessor=new g(1),this.entryX=new g(1),this.entryY=new g(1),this.scoreF=new g(1),this.scoreG=new g(1),this.scoreH=new g(1),n=M.locatePosition(t,this.mesh),0===n.type)return;if(1===n.type){if(n.isConstrained)return;this.fromFace=n.leftFace}else 2===n.type&&(this.fromFace=n);n=M.locatePosition(e,this.mesh),0===n.type?this.toFace=n.edge.leftFace:1===n.type?this.toFace=n.leftFace:2===n.type&&(this.toFace=n),this.sortedOpenedFaces.push(this.fromFace),this.entryEdges.set(this.fromFace,null),this.entryX.set(this.fromFace,t.x),this.entryY.set(this.fromFace,t.y),this.scoreG.set(this.fromFace,0);const h=c(e.x-t.x,e.y-t.y);let r,o,l,a,u;this.scoreH.set(this.fromFace,h),this.scoreF.set(this.fromFace,h);const p=new w,x=new w,f=new w;let m=!1;for(;;){if(0==this.sortedOpenedFaces.length){d("NO PATH FOUND (AStar)"),this.curFace=null;break}if(this.curFace=this.sortedOpenedFaces.pop(),this.curFace==this.toFace)break;for(this.iterEdge.fromFace=this.curFace;null!=(r=this.iterEdge.next());)if(!r.isConstrained&&(o=r.rightFace,!this.closedFaces.get(o))){if(this.curFace!=this.fromFace&&this._radius>0&&!this.isWalkableByRadius(this.entryEdges.get(this.curFace),this.curFace,r))continue;p.set(this.entryX.get(this.curFace),this.entryY.get(this.curFace)),x.set(.5*(r.originVertex.pos.x+r.destinationVertex.pos.x),.5*(r.originVertex.pos.y+r.destinationVertex.pos.y)),f.copy(x).sub(e),u=f.length(),f.copy(p).sub(x),a=this.scoreG.get(this.curFace)+f.length(),l=u+a,m=!1,null!=this.openedFaces.get(o)&&this.openedFaces.get(o)?this.scoreF.get(o)>l&&(m=!0):(this.sortedOpenedFaces.push(o),this.openedFaces.set(o,!0),m=!0),m&&(this.entryEdges.set(o,r),this.entryX.set(o,x.x),this.entryY.set(o,x.y),this.scoreF.set(o,l),this.scoreG.set(o,a),this.scoreH.set(o,u),this.predecessor.set(o,this.curFace))}this.openedFaces.set(this.curFace,!1),this.closedFaces.set(this.curFace,!0),this.sortedOpenedFaces.sort(function(t,e){return this.scoreF.get(t)==this.scoreF.get(e)?0:this.scoreF.get(t)<this.scoreF.get(e)?1:-1}.bind(this))}if(null!=this.curFace)for(s.push(this.curFace);this.curFace!=this.fromFace;)i.unshift(this.entryEdges.get(this.curFace)),this.curFace=this.predecessor.get(this.curFace),s.unshift(this.curFace)}isWalkableByRadius(t,e,s){let i,n,h,r=null,o=null,l=null;if(t.originVertex==s.originVertex?(r=t.destinationVertex,o=s.destinationVertex,l=t.originVertex):t.destinationVertex==s.destinationVertex?(r=t.originVertex,o=s.originVertex,l=t.destinationVertex):t.originVertex==s.destinationVertex?(r=t.destinationVertex,o=s.originVertex,l=t.originVertex):t.destinationVertex==s.originVertex&&(r=t.originVertex,o=s.destinationVertex,l=t.destinationVertex),i=(l.pos.x-r.pos.x)*(o.pos.x-r.pos.x)+(l.pos.y-r.pos.y)*(o.pos.y-r.pos.y),i<=0)return n=m(l.pos.x-r.pos.x,l.pos.y-r.pos.y),n>=this.diameterSquared;if(i=(l.pos.x-o.pos.x)*(r.pos.x-o.pos.x)+(l.pos.y-o.pos.y)*(r.pos.y-o.pos.y),i<=0)return n=m(l.pos.x-o.pos.x,l.pos.y-o.pos.y),n>=this.diameterSquared;if(h=e.edge!=t&&e.edge.oppositeEdge!=t&&e.edge!=s&&e.edge.oppositeEdge!=s?e.edge:e.edge.nextLeftEdge!=t&&e.edge.nextLeftEdge.oppositeEdge!=t&&e.edge.nextLeftEdge!=s&&e.edge.nextLeftEdge.oppositeEdge!=s?e.edge.nextLeftEdge:e.edge.prevLeftEdge,h.isConstrained){var a=new w(l.pos.x,l.pos.y);return M.projectOrthogonaly(a,h),n=m(a.x-l.pos.x,a.y-l.pos.y),n>=this.diameterSquared}{let t=m(l.pos.x-r.pos.x,l.pos.y-r.pos.y),s=m(l.pos.x-o.pos.x,l.pos.y-o.pos.y);if(t<this.diameterSquared||s<this.diameterSquared)return!1;{let t,s,i,n,r,o,a=[],d=[],u=new g(1);if(d.push(h),h.leftFace==e){a.push(h.rightFace);let t=h.rightFace;u.set(t,!0)}else{a.push(h.leftFace);let t=h.leftFace;u.set(t,!0)}for(;a.length>0;){if(t=a.shift(),s=d.shift(),t.edge==s||t.edge==s.oppositeEdge?(i=t.edge.nextLeftEdge,r=t.edge.nextLeftEdge.nextLeftEdge):t.edge.nextLeftEdge==s||t.edge.nextLeftEdge==s.oppositeEdge?(i=t.edge,r=t.edge.nextLeftEdge.nextLeftEdge):(i=t.edge,r=t.edge.nextLeftEdge),n=i.leftFace==t?i.rightFace:i.leftFace,o=r.leftFace==t?r.rightFace:r.leftFace,!u.get(n)&&M.distanceSquaredVertexToEdge(l,i)<this.diameterSquared){if(i.isConstrained)return!1;a.push(n),d.push(i),u.set(n,!0)}if(!u.get(o)&&M.distanceSquaredVertexToEdge(l,r)<this.diameterSquared){if(r.isConstrained)return!1;a.push(o),d.push(r),u.set(o,!0)}}return u.dispose(),!0}}}}class H{constructor(){this._currPoolPointsIndex=0,this._poolPointsSize=3e3,this._numSamplesCircle=16,this._radiusSquared=0,this._radius=0,this._poolPoints=[];let t=this._poolPointsSize,e=0;for(;e<t;)e++,this._poolPoints.push(new w)}get radius(){return this._radius}set radius(t){if(this._radius=Math.max(0,t),this._radiusSquared=this._radius*this._radius,this._sampleCircle=[],0==this._radius)return;let e,s=this._numSamplesCircle,i=0;for(;i<s;){let t=i++;e=-r*t/this._numSamplesCircle,this._sampleCircle.push(new w(this._radius*Math.cos(e),this._radius*Math.sin(e)))}this._sampleCircleDistanceSquared=m(this._sampleCircle[0].x-this._sampleCircle[1].x,this._sampleCircle[0].y-this._sampleCircle[1].y)}dispose(){this._sampleCircle=null}getPoint(t,e){return e=e||0,t=t||0,this.__point=this._poolPoints[this._currPoolPointsIndex],this.__point.set(t,e),this._currPoolPointsIndex++,this._currPoolPointsIndex==this._poolPointsSize&&(this._poolPoints.push(new w),this._poolPointsSize++),this.__point}getCopyPoint(t){return this.getPoint(t.x,t.y)}findPath(t,e,s,i,n){let h,r,o,l,a,u,p=t,c=e,x=1.01*this._radius;if(this._currPoolPointsIndex=0,this._radius>0){let t,e,i,n,h,r=s[0];i=r.edge.originVertex.pos,n=r.edge.destinationVertex.pos,h=r.edge.nextLeftEdge.destinationVertex.pos,t=m(i.x-p.x,i.y-p.y),t<=this._radiusSquared?(e=Math.sqrt(t),p.sub(i).div(e).mul(x).add(i)):(t=m(n.x-p.x,n.y-p.y),t<=this._radiusSquared?(e=Math.sqrt(t),p.sub(n).div(e).mul(x).add(n)):(t=m(h.x-p.x,h.y-p.y),t<=this._radiusSquared&&(e=Math.sqrt(t),p.sub(h).div(e).mul(x).add(h)))),r=s[s.length-1],i=r.edge.originVertex.pos,n=r.edge.destinationVertex.pos,h=r.edge.nextLeftEdge.destinationVertex.pos,t=m(i.x-c.x,i.y-c.y),t<=this._radiusSquared?(e=Math.sqrt(t),c.sub(i).div(e).mul(x).add(i)):(t=m(n.x-c.x,n.y-c.y),t<=this._radiusSquared?(e=Math.sqrt(t),c.sub(n).div(e).mul(x).add(n)):(t=m(h.x-c.x,h.y-c.y),t<=this._radiusSquared&&(e=Math.sqrt(t),c.sub(h).div(e).mul(x).add(h))))}if(h=p.clone(),r=c.clone(),1==s.length)return n.push(f(h.x)),n.push(f(h.y)),n.push(f(r.x)),void n.push(f(r.y));let _,y=null,E=null,w=M.isInFace(p,s[0]);1===w.type&&i[0]===w&&(i.length>1&&i.shift(),s.length>1&&s.shift(),d("!! isShift"));let C=[],S=[];C.push(h),S.push(h);let F=new g(1),V=[],P=new g(0),v=new g(0);P.set(h,0),y=i[0];let b,D,L,T=M.getRelativePosition2(p,y);D=this.getCopyPoint(y.destinationVertex.pos),L=this.getCopyPoint(y.originVertex.pos),V.push(D),V.push(L),v.set(h,D),v.set(D,L),b=L,1==T?(P.set(D,1),P.set(L,-1),F.set(y.destinationVertex,1),F.set(y.originVertex,-1)):-1==T&&(P.set(D,-1),P.set(L,1),F.set(y.destinationVertex,-1),F.set(y.originVertex,1));let N=i[0].originVertex,O=i[0].destinationVertex,R=1,k=i.length;for(;R<k;){y=i[R++],y.originVertex==N?E=y.destinationVertex:y.destinationVertex==N?E=y.originVertex:y.originVertex==O?(E=y.destinationVertex,N=O):y.destinationVertex==O?(E=y.originVertex,N=O):d("IMPOSSIBLE TO IDENTIFY THE VERTEX !!!"),D=this.getCopyPoint(E.pos),V.push(D),_=-F.get(N),P.set(D,_),v.set(b,D),F.set(E,_),b=D,O=N,N=E}v.set(b,r),P.set(r,0);let A,j=[],I=new g(1);j.push(h),I.set(h,0);let q=0,W=V.length;for(;q<W;){if(A=V[q++],-1==P.get(A)){for(l=C.length-2;l>=0;){if(_=M.getDirection(C[l],C[l+1],A),-1!=_){C.shift();let t=0;for(;t<l;)t++,j.push(C[0]),I.set(C[0],1),C.shift();j.push(C[0]),I.set(C[0],1),S.splice(0,S.length),S.push(C[0]),S.push(A);break}l--}for(S.push(A),l=S.length-3;l>=0&&(_=M.getDirection(S[l],S[l+1],A),-1!=_);)S.splice(l+1,1),l--}else{for(l=S.length-2;l>=0;){if(_=M.getDirection(S[l],S[l+1],A),1!=_){S.shift();let t=0;for(;t<l;)t++,j.push(S[0]),I.set(S[0],-1),S.shift();j.push(S[0]),I.set(S[0],-1),C.splice(0,C.length),C.push(S[0]),C.push(A);break}l--}for(C.push(A),l=C.length-3;l>=0&&(_=M.getDirection(C[l],C[l+1],A),1!=_);)C.splice(l+1,1),l--}}let B=!1;for(l=S.length-2;l>=0;){if(_=M.getDirection(S[l],S[l+1],c),1!=_){S.shift();let t=0,e=l+1;for(;t<e;)t++,j.push(S[0]),I.set(S[0],-1),S.shift();j.push(r),I.set(r,0),B=!0;break}l--}if(!B)for(l=C.length-2;l>=0;){if(_=M.getDirection(C[l],C[l+1],c),-1!=_){C.shift();let t=0,e=l+1;for(;t<e;)t++,j.push(C[0]),I.set(C[0],1),C.shift();j.push(r),I.set(r,0),B=!0;break}l--}B||(j.push(r),I.set(r,0),B=!0);let G=[];if(this._radius>0){let t=[];if(2==j.length)this.adjustWithTangents(j[0],!1,j[1],!1,P,v,t,G);else if(j.length>2){if(this.adjustWithTangents(j[0],!1,j[1],!0,P,v,t,G),j.length>3){let e=1,s=j.length-3+1;for(;e<s;){let s=e++;this.adjustWithTangents(j[s],!0,j[s+1],!0,P,v,t,G)}}let e=j.length;this.adjustWithTangents(j[e-2],!0,j[e-1],!1,P,v,t,G)}t.push(r),this.checkAdjustedPath(t,G,P);let e=[];for(o=t.length-2;o>=1;){for(this.smoothAngle(G[2*o-1],t[o],G[2*o],P.get(t[o]),e);0!=e.length;)G.splice(2*o,0,e.pop());o--}}else G=j;for(u=0,a=G.length;u<a;)o=u++,n.push(f(G[o].x)),n.push(f(G[o].y))}adjustWithTangents(t,e,s,i,n,h,r,o){let l=[],a=n.get(t),g=n.get(s),u=null,p=null;if(e||i)if(e)if(i)if(1==a&&1==g)M.tangentsParalCircleToCircle(this._radius,t,s,l),u=this.getPoint(l[2],l[3]),p=this.getPoint(l[4],l[5]);else if(-1==a&&-1==g)M.tangentsParalCircleToCircle(this._radius,t,s,l),u=this.getPoint(l[0],l[1]),p=this.getPoint(l[6],l[7]);else if(1==a&&-1==g){if(!M.tangentsCrossCircleToCircle(this._radius,t,s,l))return void d("NO TANGENT, points are too close for radius");u=this.getPoint(l[2],l[3]),p=this.getPoint(l[6],l[7])}else{if(!M.tangentsCrossCircleToCircle(this._radius,t,s,l))return void d("NO TANGENT, points are too close for radius");u=this.getPoint(l[0],l[1]),p=this.getPoint(l[4],l[5])}else{if(!M.tangentsPointToCircle(s,t,this._radius,l))return void d("NO TANGENT");l.length>0&&(1==a?(u=this.getPoint(l[0],l[1]),p=s):(u=this.getPoint(l[2],l[3]),p=s))}else{if(!M.tangentsPointToCircle(t,s,this._radius,l))return void d("NO TANGENT");1==g?(u=t,p=this.getPoint(l[2],l[3])):(u=t,p=this.getPoint(l[0],l[1]))}else u=t,p=s;let c,x=h.get(t);for(;x!=s;){if(c=M.distanceSquaredPointToSegment(x,u,p),c<this._radiusSquared)return this.adjustWithTangents(t,e,x,!0,n,h,r,o),void this.adjustWithTangents(x,!0,s,i,n,h,r,o);x=h.get(x)}o.push(u),o.push(p),r.push(t)}checkAdjustedPath(t,e,s){let i,n,h,r,o,l,a,d,g,u,p=!0,c=[],x=null,f=null;for(;p;){p=!1;let m=2;for(;m<t.length;)o=t[m],l=s.get(o),h=t[m-1],r=s.get(h),i=t[m-2],n=s.get(i),r==l&&(a=e[2*(m-2)],d=e[2*(m-1)-1],g=e[2*(m-1)],u=(a.x-d.x)*(g.x-d.x)+(a.y-d.y)*(g.y-d.y),u>0&&(2==m?(M.tangentsPointToCircle(i,o,this._radius,c),1==l?(x=i,f=this.getPoint(c[2],c[3])):(x=i,f=this.getPoint(c[0],c[1]))):m==t.length-1?(M.tangentsPointToCircle(o,i,this._radius,c),1==n?(x=this.getPoint(c[0],c[1]),f=o):(x=this.getPoint(c[2],c[3]),f=o)):1==n&&-1==l?(M.tangentsCrossCircleToCircle(this._radius,i,o,c),x=this.getPoint(c[2],c[3]),f=this.getPoint(c[6],c[7])):-1==n&&1==l?(M.tangentsCrossCircleToCircle(this._radius,i,o,c),x=this.getPoint(c[0],c[1]),f=this.getPoint(c[4],c[5])):1==n&&1==l?(M.tangentsParalCircleToCircle(this._radius,i,o,c),x=this.getPoint(c[2],c[3]),f=this.getPoint(c[4],c[5])):-1==n&&-1==l&&(M.tangentsParalCircleToCircle(this._radius,i,o,c),x=this.getPoint(c[0],c[1]),f=this.getPoint(c[6],c[7])),e.splice(2*(m-2),1,x),e.splice(2*m-1,1,f),t.splice(m-1,1),e.splice(2*(m-1)-1,2),c.splice(0,c.length),m--)),m++}}smoothAngle(t,e,s,i,n){let h=M.getDirection(t,e,s);if(m(t.x-s.x,t.y-s.y)<=this._sampleCircleDistanceSquared)return;let r,o,l,a,d=0,g=0,u=this._numSamplesCircle;for(;g<u;){let u=g++;l=!1,a=e.clone().add(this._sampleCircle[u]),r=M.getDirection(t,e,a),o=M.getDirection(e,s,a),1==i?-1==h?-1==r&&-1==o&&(l=!0):-1!=r&&-1!=o||(l=!0):1==h?1==r&&1==o&&(l=!0):1!=r&&1!=o||(l=!0),l?(n.splice(d,0,a),d++):d=0}-1==i&&n.reverse()}}class X{constructor(){this.astar=new G,this.funnel=new H,this.listFaces=[],this.listEdges=[],this._mesh=null,this.entity=null}get mesh(){return this._mesh}set mesh(t){this._mesh=t,this.astar.mesh=t}dispose(){this._mesh=null,this.astar.dispose(),this.astar=null,this.funnel.dispose(),this.funnel=null,this.listEdges=null,this.listFaces=null}findPath(t,e){if(e.splice(0,e.length),M.isCircleIntersectingAnyConstraint(t,this.entity.radius,this._mesh))return;this.astar.radius=this.entity.radius,this.funnel.radius=this.entity.radius,this.listFaces.splice(0,this.listFaces.length),this.listEdges.splice(0,this.listEdges.length);let s=this.entity.position;this.astar.findPath(s,t,this.listFaces,this.listEdges),0!=this.listFaces.length?this.funnel.findPath(s,t,this.listFaces,this.listEdges,e):d("PATH LENGTH = 0 (PathFinder)")}}class Y{constructor(){this.id=l.get("object2D"),this._pivot=new w,this._position=new w,this._scale=new w(1,1),this._matrix=new P,this._rotation=0,this._constraintShape=null,this._coordinates=[],this.hasChanged=!1}get rotation(){return this._rotation}set rotation(t){this._rotation!==t&&(this._rotation=t,this.hasChanged=!0)}get matrix(){return this._matrix}set matrix(t){this._rotation!==t&&(this._rotation=t,this.hasChanged=!0)}get coordinates(){return this._coordinates}set coordinates(t){this._coordinates=t,this.hasChanged=!0}get constraintShape(){return this._constraintShape}set constraintShape(t){this._constraintShape=t,this.hasChanged=!0}get edges(){let t,e=[],s=this._constraintShape.segments,i=s.length,n=0,h=0,r=0,o=0;for(;n<i;)for(r=n++,h=0,t=s[r].edges.length;h<t;)o=h++,e.push(s[r].edges[o]);return e}position(t,e){this._position.set(t,e),this.hasChanged=!0}scale(t,e){this._scale.set(t,e),this.hasChanged=!0}pivot(t,e){this._pivot.set(t,e),this.hasChanged=!0}dispose(){this._matrix=null,this._coordinates=null,this._constraintShape=null}updateValuesFromMatrix(){}updateMatrixFromValues(){this._matrix.identity().translate(this._pivot.negate()).scale(this._scale).rotate(this._rotation).translate(this._position)}}class U{constructor(t,e){this.entity=t||null,this.world=e||null}isInField(t){if(!this.world)return;if(!this.entity)return;this.mesh=this.world.getMesh();let e=this.entity.position,s=this.entity.direction,n=t.position,h=this.entity.radiusFOV,r=this.entity.angleFOV,o=t.radius;if(m(e.x-n.x,e.y-n.y)>=(h+o)*(h+o))return!1;let l,a,d=new w,u=new w,p=[];M.intersections2Circles(e,h,n,o,p)&&(d.set(p[0],p[1]),u.set(p[2],p[3]));let c=e.clone().add(n).mul(.5);(0==p.length||m(c.x-n.x,c.y-n.y)<m(c.x-d.x,c.y-d.y))&&(p.splice(0,p.length),M.tangentsPointToCircle(e,n,o,p),d.set(p[0],p[1]),u.set(p[2],p[3]));let x=Math.cos(.5*this.entity.angleFOV),f=d.clone().sub(e),_=Math.sqrt(f.x*f.x+f.y*f.y);l=f.x/_*s.x+f.y/_*s.y>x;let y=u.clone().sub(e),E=Math.sqrt(y.x*y.x+y.y*y.y);if(a=y.x/E*s.x+y.y/E*s.y>x,!l&&!a){let t=e.clone().add(s);if(1!==M.getDirection(e,t,d)||-1!==M.getDirection(e,t,u))return!1}if(!l||!a){let t,i=new w;if(t=Math.atan2(s.y,s.x),!l){let s=new w(Math.cos(t-.5*r),Math.sin(t-.5*r)).add(e);M.intersections2segments(e,s,d,u,i,null,!0),d=i.clone()}if(!a){let s=new w(Math.cos(t+.5*r),Math.sin(t+.5*r)).add(e);M.intersections2segments(e,s,d,u,i,null,!0),u=i.clone()}}let C,S=new g(0),F=new g(0),V=[],P=M.locatePosition(e,this.mesh);2==P.type?C=P:1==P.type?C=P.leftFace:0==P.type&&(C=P.edge.leftFace);let v,b,D,L,T=[],N=new g(0);T.push(C),N[C]=!0;let O,R,k,A,j,I=new w,q=new w,W=[],B=[];for(;T.length>0;)for(v=T.shift(),N.set(v,null),S.set(v,!0),b=v.edge,F.get(b)||F.get(b.oppositeEdge)||(B.push(b),F.set(b,!0)),b=b.nextLeftEdge,F.get(b)||F.get(b.oppositeEdge)||(B.push(b),F.set(b,!0)),b=b.nextLeftEdge,F.get(b)||F.get(b.oppositeEdge)||(B.push(b),F.set(b,!0));B.length>0;)if(b=B.pop(),D=b.originVertex.pos,L=b.destinationVertex.pos,M.clipSegmentByTriangle(D,L,e,u,d,I,q)){if(b.isConstrained){for(W.splice(0,W.length),M.intersections2segments(e,I,d,u,null,W,!0),M.intersections2segments(e,q,d,u,null,W,!0),O=W[1],R=W[3],R<O&&(O=R,R=W[1]),k=V.length-1;k>=0&&!(R>=V[k]);k--);for(j=k+1,j%2==0&&V.splice(j,0,R),k=0;k<V.length&&!(O<=V[k]);k++);if(A=k,A%2==0?(V.splice(A,0,O),j++):A--,V.splice(A+1,j-A-1),2==V.length&&-.01<V[0]&&V[0]<i&&.99<V[1]&&V[1]<1.01)return!1}v=b.rightFace,N.get(v)||S.get(v)||(T.push(v),N.set(v,!0))}return!0}}class K{constructor(){this.entity=null,this._path=null,this._samplingDistanceSquared=1,this._samplingDistance=1,this._preCompX=[],this._preCompY=[],this.pos=new w,this.hasPrev=!1,this.hasNext=!1,this._count=0}get x(){return this.pos.x}get y(){return this.pos.y}get countMax(){return this._preCompX.length-1}get count(){return this._count}set count(t){this._count=t,this._count<0&&(this._count=0),this._count>this.countMax-1&&(this._count=this.countMax-1),0==this._count?this.hasPrev=!1:this.hasPrev=!0,this._count==this.countMax-1?this.hasNext=!1:this.hasNext=!0,this.applyLast(),this.updateEntity()}get samplingDistance(){return this._samplingDistance}set samplingDistance(t){this._samplingDistance=t,this._samplingDistanceSquared=this._samplingDistance*this._samplingDistance}get path(){return this._path}set path(t){this._path=t,this._preComputed=!1,this.reset()}dispose(){this.entity=null,this._path=null,this._preCompX=null,this._preCompY=null}reset(){this._path.length>0?(this.pos.x=this._path[0],this.pos.y=this._path[1],this._iPrev=0,this._iNext=2,this.hasPrev=!1,this.hasNext=!0,this._count=0,this.updateEntity()):(this.hasPrev=!1,this.hasNext=!1,this._count=0)}preCompute(){for(this._preCompX.splice(0,this._preCompX.length),this._preCompY.splice(0,this._preCompY.length),this._count=0,this._preCompX.push(this.pos.x),this._preCompY.push(this.pos.y),this._preComputed=!1;this.next();)this._preCompX.push(this.pos.x),this._preCompY.push(this.pos.y);this.reset(),this._preComputed=!0}prev(){if(!this.hasPrev)return!1;if(this.hasNext=!0,this._preComputed)return this._count--,0==this._count&&(this.hasPrev=!1),this.applyLast(),this.updateEntity(),!0;let t,e;for(t=this._samplingDistance;;){let s=this._path[this._iPrev],i=this._path[this._iPrev+1];if(e=c(this.pos.x-s,this.pos.y-i),!(e<t))break;if(t-=e,this._iPrev-=2,this._iNext-=2,0==this._iNext)break}return 0==this._iNext?(this.pos.x=this._path[0],this.pos.y=this._path[1],this.hasPrev=!1,this._iNext=2,this._iPrev=0,this.updateEntity(),!0):(this.pos.x=this.pos.x+(this._path[this._iPrev]-this.pos.x)*t/e,this.pos.y=this.pos.y+(this._path[this._iPrev+1]-this.pos.y)*t/e,this.updateEntity(),!0)}next(){if(!this.hasNext)return!1;if(this.hasPrev=!0,this._preComputed)return this._count++,this._count==this._preCompX.length-1&&(this.hasNext=!1),this.applyLast(),this.updateEntity(),!0;let t,e;for(t=this._samplingDistance;;){let s=this._path[this._iNext],i=this._path[this._iNext+1];if(e=c(this.pos.x-s,this.pos.y-i),!(e<t))break;if(t-=e,this.pos.x=this._path[this._iNext],this.pos.y=this._path[this._iNext+1],this._iPrev+=2,this._iNext+=2,this._iNext==this._path.length)break}return this._iNext==this._path.length?(this.pos.x=this._path[this._iPrev],this.pos.y=this._path[this._iPrev+1],this.hasNext=!1,this._iNext=this._path.length-2,this._iPrev=this._iNext-2,this.updateEntity(),!0):(this.pos.x=this.pos.x+(this._path[this._iNext]-this.pos.x)*t/e,this.pos.y=this.pos.y+(this._path[this._iNext+1]-this.pos.y)*t/e,this.updateEntity(),!0)}applyLast(){this.pos.set(this._preCompX[this._count],this._preCompY[this._count])}updateEntity(){null!==this.entity&&(this.entity.distance=this.entity.position.distanceTo(this.pos),this.entity.needTurn||(this.entity.angle=this.entity.position.angleTo(this.pos)),this.entity.direction.angular(this.entity.angle).mul(this.entity.distance),this.entity.position.copy(this.pos))}}class z{constructor(t={},s){this.isSee=!1,this.isWalking=!1,this.isSelected=!1,this.isMove=!1,this.isTurn=!1,this.isActive=!1,this.world=s,this.turnSpeed=t.turn||0,this.turnStep=0,this.needTurn=!1,this.step=0,this.color={r:255,g:255,b:255,a:.75},this.color2={r:0,g:0,b:255,a:.75},this.position=new w(t.x||0,t.y||0),this.direction=new w(1,0),this.distance=0,this.radius=t.r||10,this.angle=t.angle||0,this.angleNext=0,this.angleFOV=(t.fov||120)*e,this.radiusFOV=t.distance||200,this.testSee=t.see||!1,this.angledelta=0,this.turnStep=0,this.needTurn=!1,this.path=[],this.tmppath=[],this.target=new w,this.newPath=!1,this.mesh=null,this.fov=new U(this,this.world),this.pathSampler=new K,this.pathSampler.entity=this,this.pathSampler.path=this.tmppath,this.pathSampler.samplingDistance=t.speed||10}clearTarget(){this.pathSampler.hasNext&&(this.pathSampler.hasPrev=!1,this.pathSampler.hasNext=!1,this.pathSampler._count=0),this.isActive=!1}setAngle(t){this.angle=p(t)}setTarget(t,e,s){return this.path=[],this.target.set(t,e),this.world.pathFinder.entity=this,this.world.pathFinder.findPath(this.target,this.path),this.testPath(s)}testPath(t){if(!this.path)return!1;if(this.path.length>0){const e=void 0!==t?p(t):this.angle;if(0!==this.turnSpeed&&(this.needTurn=!0),this.pathSampler.reset(),this.tmppath=[...this.path],this.pathSampler.path=this.tmppath,this.newPath=!0,this.step=0,this.turnStep=0,0!==this.turnSpeed&&this.tmppath.length>=4){this.angleNext=this.position.angleTo({x:this.tmppath[2],y:this.tmppath[3]});let t=this.getNear(this.angleNext,e);this.turnStep=Math.floor(Math.abs(Math.round(t*s))/this.turnSpeed),this.angledelta=t/this.turnStep,this.needTurn=!0,this.step=0,(this.angledelta===1/0||this.angledelta===-1/0||isNaN(this.angledelta))&&(this.angledelta=0,this.turnStep=0,this.needTurn=!1)}return!0}}getNear(t,e){return Math.atan2(Math.sin(t-e),Math.cos(t-e))}getPos(){return{x:this.position.x,y:this.position.y,r:-this.angle}}update(){var t;this.pathSampler.hasNext?this.needTurn?(this.isTurn=!0,this.step++,this.angle+=this.angledelta,this.step===this.turnStep&&(this.needTurn=!1)):(this.newPath=!1,this.isMove=!0,this.isTurn=!1,this.pathSampler.next()):(this.isMove=!1,this.isTurn=!1,this.tmppath=[]),this.isActive=!(!this.isMove&&!this.isTurn),this.isMove&&!this.isWalking&&(this.isWalking=!0),!this.isMove&&this.isWalking&&(this.isWalking=!1),null!==this.mesh&&(t=this.getPos(),this.mesh.position.set(t.x,0,t.y),this.mesh.rotation.y=t.r-.5*Math.PI)}}function Z(t,e){this.visited=!1,this.col=t,this.row=e;let s=[],i=0;for(;i<4;)i++,s.push([]);this.walls=s}class J{constructor(t,e,s,i){this.w=t||200,this.h=e||200,this.canvas=document.createElement("canvas"),this.canvas.width=this.w,this.canvas.height=this.h,this.ctx=this.canvas.getContext("2d"),this.canvas.style.cssText=i||"position:absolute; left:50%; top:50%; margin-left:"+.5*-this.w+"px; margin-top:"+.5*-this.h+"px;",void 0===s&&(s=document.body),s.appendChild(this.canvas)}clear(){this.ctx.clearRect(0,0,this.w,this.h)}drawImage(t,e,s){this.ctx.drawImage(t,0,0,e||this.w,s||this.h)}drawCircle(t,e,s,i,n){i=i||0,n=n||r,this.ctx.beginPath(),this.ctx.arc(t,e,s,i,n,!1)}drawRect(t,e,s,i){this.ctx.beginPath(),this.ctx.moveTo(t,e),this.ctx.lineTo(t+s,e),this.ctx.lineTo(t+s,e+i),this.ctx.lineTo(t,e+i),this.ctx.stroke(),this.ctx.closePath()}lineStyle(t,e){this.ctx.lineWidth=t,this.ctx.strokeStyle="rgba("+e.r+","+e.g+","+e.b+","+e.a+")"}moveTo(t,e){this.ctx.beginPath(),this.ctx.moveTo(t,e)}lineTo(t,e){this.ctx.lineTo(t,e)}stroke(){this.ctx.stroke()}closePath(){this.ctx.closePath()}beginFill(t){this.ctx.fillStyle="rgba("+t.r+","+t.g+","+t.b+","+t.a+")",this.ctx.beginPath()}endFill(){this.ctx.closePath(),this.ctx.fill()}}function Q(t,e,s){let i=s;this.world=e,this.maxVertices=3e4,this.currentVertex=0;let n=new i.BufferGeometry;n.addAttribute("position",new i.BufferAttribute(new Float32Array(3*this.maxVertices),3)),n.addAttribute("color",new i.BufferAttribute(new Float32Array(3*this.maxVertices),3)),this.positions=n.attributes.position.array,this.colors=n.attributes.color.array,n.computeBoundingSphere(),this.buffer=new i.LineSegments(n,new i.LineBasicMaterial({vertexColors:!0})),this.buffer.frustumCulled=!1,t.add(this.buffer),this.maxPathVertices=1e3,this.currentPathVertex=0;let h=new i.BufferGeometry;h.addAttribute("position",new i.BufferAttribute(new Float32Array(3*this.maxPathVertices),3)),h.addAttribute("color",new i.BufferAttribute(new Float32Array(3*this.maxPathVertices),3)),this.positionsPath=h.attributes.position.array,this.colorsPath=h.attributes.color.array,n.computeBoundingSphere(),this.bufferPath=new i.LineSegments(h,new i.LineBasicMaterial({vertexColors:!0})),this.bufferPath.frustumCulled=!1,t.add(this.bufferPath),o.set(this)}Q.prototype={constructor:Q,drawMesh:function(t,e){},collapseBuffer:function(){let t=this.maxVertices,e=this.currentVertex,s=0;for(;t>=e;)s=3*t,this.positions[s]=0,this.positions[s+1]=0,this.positions[s+2]=0,this.colors[s]=0,this.colors[s+1]=0,this.colors[s+2]=0,t--},collapsePathBuffer:function(){let t=this.maxPathVertices,e=this.currentPathVertex,s=0;for(;t>=e;)s=3*t,this.positionsPath[s]=0,this.positionsPath[s+1]=0,this.positionsPath[s+2]=0,this.colorsPath[s]=0,this.colorsPath[s+1]=0,this.colorsPath[s+2]=0,t--},update:function(){this.world.mesh.isRedraw&&(this.currentVertex=0,this.world.mesh.draw(),this.collapseBuffer(),this.buffer.geometry.attributes.position.needsUpdate=!0,this.buffer.geometry.attributes.color.needsUpdate=!0),this.world.update();let t,e=this.world.heroes.length;for(;e--;)if(t=this.world.heroes[e],t.isSelected&&t.tmppath.length>0){this.currentPathVertex=0;let t=this.world.heroes[e].tmppath,s=t[0],i=t[1],n=2;for(;n<t.length;)this.insertPath(s,i,t[n],t[n+1],1,0,0),s=t[n],i=t[n+1],n+=2;this.collapsePathBuffer(),this.bufferPath.geometry.attributes.position.needsUpdate=!0,this.bufferPath.geometry.attributes.color.needsUpdate=!0}},insertLine:function(t,e,s,i,n,h,r){let o=this.currentVertex,l=3*o;this.positions[l]=t,this.positions[l+1]=0,this.positions[l+2]=e,this.colors[l]=n,this.colors[l+1]=h,this.colors[l+2]=r,o++,l=3*o,this.positions[l]=s,this.positions[l+1]=0,this.positions[l+2]=i,this.colors[l]=n,this.colors[l+1]=h,this.colors[l+2]=r,this.currentVertex+=2},insertPath:function(t,e,s,i,n,h,r){let o=this.currentPathVertex,l=3*o;this.positionsPath[l]=t,this.positionsPath[l+1]=0,this.positionsPath[l+2]=e,this.colorsPath[l]=n,this.colorsPath[l+1]=h,this.colorsPath[l+2]=r,o++,l=3*o,this.positionsPath[l]=s,this.positionsPath[l+1]=0,this.positionsPath[l+2]=i,this.colorsPath[l]=n,this.colorsPath[l+1]=h,this.colorsPath[l+2]=r,this.currentPathVertex+=2}},O.prototype.draw=function(){this.compute_Data();let t=o.get(),e=this.AR_edge,s=e.length,i=0;for(;s--;)i=5*s,e[i+4]?t.insertLine(e[i],e[i+1],e[i+2],e[i+3],0,0,0):t.insertLine(e[i],e[i+1],e[i+2],e[i+3],.4,.4,.4);this.isRedraw=!1},t.Debug=a,t.Dungeon=class{constructor(t,e,s,i){this.generate(t,e,s,i)}generate(t,e,s,i){let n,h,r;for(this.w=t/10,this.h=e/10,this.rooms=[],this.map=[],h=0;h<this.w;h++)for(this.map[h]=[],r=0;r<this.h;r++)this.map[h][r]=0;let o=u(10,20),l=s||5,a=i||15;for(n=0;n<o;n++){let t={};t.x=u(1,this.w-a-1),t.y=u(1,this.h-a-1),t.w=u(l,a),t.h=u(l,a),this.DoesCollide(t)?n--:(t.w--,t.h--,this.rooms.push(t))}for(this.SquashRooms(),n=0;n<o;n++){let t=this.rooms[n],e=this.FindClosestRoom(t),s={x:u(t.x,t.x+t.w),y:u(t.y,t.y+t.h)},i={x:u(e.x,e.x+e.w),y:u(e.y,e.y+e.h)};for(;i.x!=s.x||i.y!=s.y;)i.x!=s.x?i.x>s.x?i.x--:i.x++:i.y!=s.y&&(i.y>s.y?i.y--:i.y++),this.map[i.x][i.y]=1}for(n=0;n<o;n++){let t=this.rooms[n];for(let e=t.x;e<t.x+t.w;e++)for(let s=t.y;s<t.y+t.h;s++)this.map[e][s]=1}for(h=0;h<this.w;h++)for(r=0;r<this.h;r++)if(1==this.map[h][r])for(let t=h-1;t<=h+1;t++)for(let e=r-1;e<=r+1;e++)0==this.map[t][e]&&(this.map[t][e]=2);this.populateObject()}FindClosestRoom(t){let e=t.x+t.w/2,s=t.y+t.h/2,i=null,n=1e3;for(let h=0;h<this.rooms.length;h++){let r=this.rooms[h];if(r==t)continue;let o={x:r.x+r.w/2,y:r.y+r.h/2},l=Math.min(Math.abs(e-o.x)-t.w/2-r.w/2,Math.abs(s-o.y)-t.h/2-r.h/2);l<n&&(n=l,i=r)}return i}SquashRooms(){for(let t=0;t<10;t++)for(let t=0;t<this.rooms.length;t++){let e=this.rooms[t];for(;;){let s={x:e.x,y:e.y};if(e.x>1&&e.x--,e.y>1&&e.y--,1==e.x&&1==e.y)break;if(this.DoesCollide(e,t)){e.x=s.x,e.y=s.y;break}}}}DoesCollide(t,e){for(let s=0;s<this.rooms.length;s++){if(s==e)continue;let i=this.rooms[s];if(!(t.x+t.w<i.x||t.x>i.x+i.w||t.y+t.h<i.y||t.y>i.y+i.h))return!0}return!1}populateObject(){let t=document.createElement("canvas");t.width=10*this.w,t.height=10*this.h;let e=t.getContext("2d");e.fillStyle="#FFF",e.fillRect(0,0,t.width,t.height);for(let t=0;t<this.h;t++)for(let s=0;s<this.w;s++){let i=this.map[s][t];e.fillStyle=0===i?"#000000":1===i?"#FFFFFF":"#000000",e.fillRect(10*s,10*t,10,10)}let s=y(null,e.getImageData(0,0,10*this.w,10*this.h),10*this.w,10*this.h);this.object=class{static buildFromBmpData(t,e=1,s){void 0!==s&&W.setColor(s);let i=(e=e||1)>=1;const n=W.buildShapes(t);let h,r,o=n.length,l=0,a=0;const d=new Y;for(;o--;){for(i&&(n[l]=B(n[l],e)),r=W.buildPolygon(W.buildGraph(n[l])),h=.5*(r.length-2),a=0;h--;)d.coordinates.push(r[a],r[a+1],r[a+2],r[a+3]),a+=2;d.coordinates.push(r[0],r[1],r[a],r[a+1]),l++}return d}}.buildFromBmpData(s,1.8)}},t.GridMaze=class{constructor(t,e,s,i){this.generate(t,e,s,i)}generate(t,e,s,i){this.tileWidth=t/s|0,this.tileHeight=e/i|0,this.cols=s,this.rows=i,this.rng=new v(u(1234,7259)),this.makeGrid(),this.traverseGrid(),this.populateObject()}makeGrid(){this.grid=[];let t=0,e=this.cols;for(;t<e;){let e=t++;this.grid[e]=[];let s=0,i=this.rows;for(;s<i;){let t=s++,i=new Z(e,t);this.grid[e][t]=i;let n=[e*this.tileWidth,t*this.tileHeight],h=[(e+1)*this.tileWidth,t*this.tileHeight],r=[e*this.tileWidth,(t+1)*this.tileHeight],o=[(e+1)*this.tileWidth,(t+1)*this.tileHeight];i.walls[0]=n.concat(h),i.walls[1]=h.concat(o),i.walls[2]=r.concat(o),0==t&&0==e||(i.walls[3]=n.concat(r))}}}traverseGrid(){let t=[0,1,0,-1],e=[-1,0,1,0],s=[2,3,0,1],i=this.rng.nextInRange(0,this.cols-1),n=this.rng.nextInRange(0,this.rows-1),h=[this.grid[i][n]];for(;h.length>0;){let i=h.length-1,n=h[i];n.visited=!0;let r=[0,1,2,3];this.rng.shuffle(r);let o=0;for(;o<r.length;){let l=r[o];++o;let a=n.col+t[l],d=n.row+e[l];if(a>=0&&a<this.cols&&d>=0&&d<this.rows&&!this.grid[a][d].visited){let t=this.grid[a][d];n.walls[l]=[],t.walls[s[l]]=[],t.visited=!0,h.push(t),i=-1;break}}i>=0&&h.splice(i,1)}}populateObject(){this.object=new Y;let t=[],e=0,s=this.cols;for(;e<s;){let s=e++,i=0,n=this.rows;for(;i<n;){let e=i++,n=0,h=this.grid[s][e].walls;for(;n<h.length;){let e=h[n];++n;let s=0;for(;s<e.length;){let i=e[s];++s,t.push(i)}}}}this.object.coordinates=t}},t.Point=w,t.REVISION="1.0.0",t.SimpleView=class{constructor(t,e,s){this.g0=new J(t.w,t.h,e,s),this.g=new J(t.w,t.h,e,s),this.g.canvas.style.pointerEvents="none",this.g0.canvas.style.pointerEvents="auto",this.entitiesWidth=2,this.entitiesColor={r:0,g:0,b:255,a:.75},this.entitiesColor2={r:255,g:255,b:255,a:.75},this.entitiesField={r:0,g:0,b:255,a:.1},this.entitiesField2={r:255,g:255,b:255,a:.1},this.pathsWidth=2,this.pathsColor={r:255,g:255,b:0,a:.75},this.verticesRadius=1,this.verticesColor={r:255,g:120,b:0,a:.5},this.constraintsWidth=2,this.constraintsColor={r:0,g:255,b:0,a:1},this.edgesWidth=1,this.edgesColor={r:190,g:190,b:190,a:.25},this.edgesColor2={r:0,g:190,b:0,a:.25},this.mesh_data=null,this.domElement=this.g0.canvas,this.extraEdge=function(t,e){},o.set(this)}drawImage(t,e,s){this.g0.drawImage(t,e,s)}drawMesh(t,e){let s=this.g0;void 0!==e&&e&&this.g0.clear(),t.compute_Data();let i=t.AR_edge,n=t.AR_vertex,h=i.length,r=0;for(;h--;)r=5*h,i[r+4]?(s.lineStyle(this.constraintsWidth,this.constraintsColor),this.extraEdge([i[r],i[r+1]],[i[r+2],i[r+3]])):s.lineStyle(this.edgesWidth,this.edgesColor),s.moveTo(i[r],i[r+1]),s.lineTo(i[r+2],i[r+3]),s.stroke(),s.closePath();for(s.lineStyle(this.verticesRadius,this.verticesColor),h=n.length;h--;)r=2*h,s.beginFill(this.verticesColor,this.verticesAlpha),s.drawCircle(n[r],n[r+1],this.verticesRadius),s.endFill()}drawEntity(t,e){let s=this.g,i=t.isSee;void 0!==e&&e&&s.clear(),i?s.beginFill(this.entitiesField):s.beginFill(this.entitiesField2),s.moveTo(t.position.x,t.position.y),s.drawCircle(t.position.x,t.position.y,t.radiusFOV,t.angle-.5*t.angleFOV,t.angle+.5*t.angleFOV),s.lineTo(t.position.x,t.position.y),s.endFill(),s.beginFill(i?t.color2:t.color),s.lineStyle(this.entitiesWidth,this.entitiesColor2),s.drawCircle(t.position.x,t.position.y,t.radius),s.stroke(),s.endFill()}drawPath(t,e){let s=this.g;if(void 0!==e&&e&&this.g.clear(),0===t.length)return;s.lineStyle(this.pathsWidth,this.pathsColor),s.moveTo(t[0],t[1]);let i=2;for(;i<t.length;)s.lineTo(t[i],t[i+1]),i+=2;s.stroke()}clear(){this.g.clear()}},t.ThreeView=Q,t.TwoPI=r,t.World=class{constructor(t=512,e=512){l.reset(),this.heroes=[],this.shapes=[],this.segments=[],this.objects=[],this.w=t,this.h=e,this.mesh=new R(this.w,this.h),this.pathFinder=new X,this.pathFinder.mesh=this.mesh}getMesh(){return this.mesh}update(){let t,e,s=this.heroes.length,i=s;for(;i--;)if(e=this.heroes[i],e.update(),e.testSee)for(t=s;t--;)i!==t&&(this.heroes[i].isSee=this.heroes[i].fov.isInField(this.heroes[t]))}updateMesh(){this.mesh.updateObjects()}updateAll(){this.mesh.updateAll()}add(t){this.mesh.insertObject(t),this.objects.push(t)}addHeroe(t){let e=new z(t,this);return this.heroes.push(e),e}addObject(t={}){let s=new Y;return s.coordinates=t.coord||[-1,-1,1,-1,1,-1,1,1,1,1,-1,1,-1,1,-1,-1],s.position(t.x||1,t.y||1),s.scale(t.w||1,t.h||1),s.pivot(t.px||0,t.py||0),s.rotation=t.r*e||0,this.mesh.insertObject(s),this.objects.push(s),s}reset(t,e){this.mesh.dispose(),t&&(this.w=t),e&&(this.h=e),this.mesh=new R(this.w,this.h),this.pathFinder.mesh=this.mesh}rebuild(t){this.mesh.clear(!0),this.mesh=void 0!==t?t:new R(this.w,this.h),this.pathFinder.mesh=this.mesh;let e=this.objects.length,s=0;for(;e--;)this.objects[s]._constraintShape=null,this.mesh.insertObject(this.objects[s]),s++}addBitmapZone(t={}){if(t.url){let e=document.createElement("img");e.onload=function(){t.pixel=y(e),this.updateBitmapZone(t)}.bind(this),e.src=t.url}if(t.canvas){let e=t.canvas.width,s=t.canvas.height;t.pixel=y(null,t.canvas.getContext("2d").getImageData(0,0,e,s),e,s),this.updateBitmapZone(t)}t.img&&(t.pixel=y(t.img),this.updateBitmapZone(t))}updateBitmapZone(t={}){this.mesh.dispose(),this.mesh=class{static buildFromBmpData(t,e=1,s){void 0!==s&&W.setColor(s);let i=(e=e||1)>=1;const n=W.buildShapes(t);let h,r,o=n.length,l=0,a=0;const d=new R(t.width,t.height);for(;o--;){for(i&&(n[l]=B(n[l],e)),r=W.buildPolygon(W.buildGraph(n[l])),h=.5*(r.length-2),a=0;h--;)d.insertConstraintSegment(r[a],r[a+1],r[a+2],r[a+3]),a+=2;d.insertConstraintSegment(r[0],r[1],r[a],r[a+1]),l++}return d}}.buildFromBmpData(t.pixel,t.precision,t.color),this.pathFinder.mesh=this.mesh;let e=o.get();e&&e.drawMesh(this.mesh)}},t.rand=(t,e)=>t+Math.random()*(e-t),t.randInt=u,Object.defineProperty(t,"__esModule",{value:!0})}));
