/**
 * @license
 * Copyright 2010-2022 Ddls.js Authors lo-th
 * SPDX-License-Identifier: MIT
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).DDLS={})}(this,(function(t){"use strict";void 0===Number.EPSILON&&(Number.EPSILON=Math.pow(2,-52)),void 0===Math.sign&&(Math.sign=function(t){return t<0?-1:t>0?1:+t}),void 0===Function.prototype.name&&Object.defineProperty(Function.prototype,"name",{get:function(){return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]}}),void 0===Object.assign&&(Object.assign=function(t){if(null==t)throw new TypeError("Cannot convert undefined or null to object");for(var e=Object(t),s=1;s<arguments.length;s++){var i=arguments[s];if(null!=i)for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&(e[n]=i[n])}return e});const e=.3333333333333333,s=Math.PI/180,i=180/Math.PI,n=.01,h=1e-4,r=1/0,o=2*Math.PI;var a={view:null,get:function(){return this.view},set:function(t){this.view=t}};const l={id:{segment:0,shape:0,edge:0,face:0,mesh2D:0,object2D:0,vertex:0,graph:0,graphEdge:0,graphNode:0},get:function(t){return this.id[t]++,this.id[t]},reset:function(){this.id={segment:0,shape:0,edge:0,face:0,mesh2D:0,object2D:0,vertex:0,graph:0,graphEdge:0,graphNode:0}}};var d={callback:function(t){console.log(t)},log:function(t){this.callback(t)}};const g=t=>{d.log(t)};class u{constructor(t=0){this.type=t,this.m=new Map}set(t,e){this.m.set(1===this.type?t.id:t,e)}get(t){return this.m.has(1===this.type?t.id:t)?this.m.get(1===this.type?t.id:t):null}remove(t){this.m.delete(1===this.type?t.id:t)}dispose(){this.m.clear()}}class p{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}transform(t){return t.tranform(this),this}copy(t){return this.x=t.x,this.y=t.y,this}clone(){return new p(this.x,this.y)}sub(t){return this.x-=t.x,this.y-=t.y,this}mul(t){return this.x*=t,this.y*=t,this}add(t){return this.x+=t.x,this.y+=t.y,this}div(t){let e=1/t;return this.x*=e,this.y*=e,this}negate(){return new p(-this.x,-this.y)}transformMat2D(t){let e=this.x,s=this.y,i=t.n;return this.x=i[0]*e+i[2]*s+i[4],this.y=i[1]*e+i[3]*s+i[5],this}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}angular(t){return this.x=Math.cos(t),this.y=Math.sin(t),this}normalize(){const t=this.length();return this.x/=t,this.y/=t,this}distanceTo(t){let e=t.x-this.x,s=t.y-this.y;return Math.sqrt(e*e+s*s)}distanceSquaredTo(t){let e=t.x-this.x,s=t.y-this.y;return e*e+s*s}equals(t){return this.x===t.x&&this.y===t.y}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){return Math.atan2(t.y-this.y,t.x-this.x)}}class c{constructor(t=1,e=0,s=0,i=1,n=0,h=0){this.n=[t||1,e||0,s||0,i||1,n||0,h||0]}identity(){return this.n=[1,0,0,1,0,0],this}translate(t){let e=this.n;return e[4]+=t.x,e[5]+=t.y,this}scale(t){let e=this.n;return e[0]*=t.x,e[1]*=t.y,e[2]*=t.x,e[3]*=t.y,e[4]*=t.x,e[5]*=t.y,this}rotate(t){let e=this.n,s=e[0],i=e[1],n=e[2],h=e[3],r=e[4],o=e[5],a=Math.sin(t),l=Math.cos(t);return e[0]=s*l+i*a,e[1]=-s*a+i*l,e[2]=n*l+h*a,e[3]=-n*a+l*h,e[4]=l*r+a*o,e[5]=l*o-a*r,this}tranform(t){let e=this.n,s=e[0]*t.x+e[2]*t.y+e[4],i=e[1]*t.x+e[3]*t.y+e[5];t.x=s,t.y=i}transformX(t,e){let s=this.n;return s[0]*t+s[2]*e+s[4]}transformY(t,e){let s=this.n;return s[1]*t+s[3]*e+s[5]}concat(t){let e=this.n,s=t.n,i=e[0]*s[0]+e[1]*s[2],n=e[0]*s[1]+e[1]*s[3],h=e[2]*s[0]+e[3]*s[2],r=e[2]*s[1]+e[3]*s[3],o=e[4]*s[0]+e[5]*s[2]+s[4],a=e[4]*s[1]+e[5]*s[3]+s[5];return e[0]=i,e[1]=n,e[2]=h,e[3]=r,e[4]=o,e[5]=a,this}clone(){let t=this.n;return new c(t[0],t[1],t[2],t[3],t[4],t[5])}}const x=(t,e)=>t+Math.floor(Math.random()*(e-t+1)),f=t=>t-2*Math.floor((t+Math.PI)/(2*Math.PI))*Math.PI,_=(t,e)=>Math.sqrt(t*t+e*e),m=(t,e,s)=>Math.abs(t-e)<s,y=(t,e)=>1*t.toFixed(e||3),E=(t,e)=>t*t+e*e,w=t=>Math.floor(t),C=(t,e,s,i)=>{let n,h;t&&(s=t.width,i=t.height,n=document.createElement("canvas"),n.width=s,n.height=i,h=n.getContext("2d"),h.drawImage(t,0,0,s,i),e=h.getImageData(0,0,s,i));const r={bytes:e.data,width:s,height:i};return t&&(h.clearRect(0,0,s,i),n=null,h=null),r};class S{constructor(t=1234,e=0,s=1){this.min=e,this.max=s,this.seed=this.currentSeed=t,this.nid=0}getSeed(){return this.seed}setSeed(t){this.seed=this.currentSeed=t}reset(){this.currentSeed=this.seed,this.nid=0}next(){let t=1*this.currentSeed,e=(t*t).toString();for(;e.length<8;)e="0"+e;this.currentSeed=parseInt(e.substr(1,5));let s=Math.round(this.min+this.currentSeed/99999*(this.max-this.min));return 0===this.currentSeed&&(this.currentSeed=this.seed+this.nid),this.nid++,200===this.nid&&this.reset(),s}nextInRange(t,e){return this.min=t,this.max=e,this.next()}shuffle(t){let e,s,i=t.length;for(;i--;)e=this.nextInRange(0,i),s=t[i],t[i]=t[e],t[e]=s}}class F{constructor(){this._fromFace=null,this._nextEdge=null}set fromFace(t){this._fromFace=t,this._nextEdge=this._fromFace.edge}next(){return null!=this._nextEdge?(this._resultEdge=this._nextEdge,this._nextEdge=this._nextEdge.nextLeftEdge,this._nextEdge==this._fromFace.edge&&(this._nextEdge=null)):this._resultEdge=null,this._resultEdge}}//!\\ not used
//!\\ not used
class V{constructor(){this._fromMesh=null,this._currIndex=0}set fromMesh(t){this._fromMesh=t,this._currIndex=0}next(){do{if(!(this._currIndex<this._fromMesh._vertices.length)){this._resultVertex=null;break}this._resultVertex=this._fromMesh._vertices[this._currIndex],this._currIndex++}while(!this._resultVertex.isReal);return this._resultVertex}}//!\\ not used
class P{constructor(){this._fromVertex=null,this._nextEdge=null}set fromVertex(t){this._fromVertex=t,this._nextEdge=this._fromVertex.edge}next(){if(null!=this._nextEdge){do{if(this._resultFace=this._nextEdge.leftFace,this._nextEdge=this._nextEdge.rotLeftEdge,this._nextEdge==this._fromVertex.edge){this._nextEdge=null,this._resultFace.isReal||(this._resultFace=null);break}}while(!this._resultFace.isReal)}else this._resultFace=null;return this._resultFace}}class v{constructor(){this._fromVertex=null,this._nextEdge=null}set fromVertex(t){for(this._fromVertex=t,this._nextEdge=this._fromVertex.edge;!this._nextEdge.isReal;)this._nextEdge=this._nextEdge.rotLeftEdge}next(){if(null!=this._nextEdge){this._resultEdge=this._nextEdge.oppositeEdge;do{if(this._nextEdge=this._nextEdge.rotLeftEdge,this._nextEdge==this._fromVertex.edge){this._nextEdge=null;break}}while(!this._nextEdge.isReal)}else this._resultEdge=null;return this._resultEdge}}class b{constructor(){this.realEdgesOnly=!0,this._fromVertex=null,this._nextEdge=null}set fromVertex(t){if(this._fromVertex=t,this._nextEdge=this._fromVertex.edge,null!=this._nextEdge)for(;this.realEdgesOnly&&!this._nextEdge.isReal;)this._nextEdge=this._nextEdge.rotLeftEdge}next(){if(null!=this._nextEdge){this._resultEdge=this._nextEdge;do{if(this._nextEdge=this._nextEdge.rotLeftEdge,this._nextEdge==this._fromVertex.edge){this._nextEdge=null;break}}while(this.realEdgesOnly&&!this._nextEdge.isReal)}else this._resultEdge=null;return this._resultEdge}}//!\\ not used
const D={__samples:[],__circumcenter:new p,_randGen:null,locatePosition:function(t,s){let i,n,h,o,a;for(null===D._randGen&&(D._randGen=new S),D._randGen.setSeed(w(10*t.x+4*t.y)),D.__samples.splice(0,D.__samples.length),n=w(Math.pow(s._vertices.length,e)),D._randGen.min=0,D._randGen.max=s._vertices.length-1,i=0;i<n;)D.__samples.push(s._vertices[D._randGen.next()]),i++;let l=r,d=null;for(i=0;i<n;)h=D.__samples[i],o=h.pos,a=E(o.x-t.x,o.y-t.y),a<l&&(l=a,d=h),i++;let p=new P;null===d&&g("no closedVertex find ?"),p.fromVertex=d;let c,x=p.next(),f=new u(0),_=new F,m=0,y=0,C=D.isInFace(t,x);for(;f.get(x)||3===C.type;){if(f.set(x,!0),y++,50==y&&g("WALK TAKE MORE THAN 50 LOOP"),1e3==y){g("WALK TAKE MORE THAN 1000 LOOP -> WE ESCAPE"),C={type:3};break}_.fromFace=x;do{if(c=_.next(),null===c)return g("KILL PATH"),null;m=D.getRelativePosition(t,c)}while(1==m||0==m);x=c.rightFace,C=D.isInFace(t,x)}return f.dispose(),C},isCircleIntersectingAnyConstraint:function(t,e,s){if(t.x<=0||t.x>=s.width||t.y<=0||t.y>=s.height)return!0;let i,n=D.locatePosition(t,s);switch(n.type){case 0:i=n.edge.leftFace;break;case 1:i=n.leftFace;break;case 2:i=n;break;case 3:i=null}let h,r,o=e*e;if(h=i.edge.originVertex.pos,r=E(h.x-t.x,h.y-t.y),r<=o)return!0;if(h=i.edge.nextLeftEdge.originVertex.pos,r=E(h.x-t.x,h.y-t.y),r<=o)return!0;if(h=i.edge.nextLeftEdge.nextLeftEdge.originVertex.pos,r=E(h.x-t.x,h.y-t.y),r<=o)return!0;let a,l,d,g=[];g.push(i.edge),g.push(i.edge.nextLeftEdge),g.push(i.edge.nextLeftEdge.nextLeftEdge);let p,c=new u(0);for(;g.length>0;)if(a=g.pop(),c.set(a,!0),l=a.originVertex.pos,d=a.destinationVertex.pos,p=D.intersectionsSegmentCircle(l,d,t,e),p){if(a.isConstrained)return!0;a=a.oppositeEdge.nextLeftEdge,c.get(a)||c.get(a.oppositeEdge)||-1!=g.indexOf(a)||-1!=g.indexOf(a.oppositeEdge)||g.push(a),a=a.nextLeftEdge,c.get(a)||c.get(a.oppositeEdge)||-1!=g.indexOf(a)||-1!=g.indexOf(a.oppositeEdge)||g.push(a)}return!1},getDirection:function(t,e,s){let i=(s.x-t.x)*(e.y-t.y)+(s.y-t.y)*(-e.x+t.x);return 0==i?0:i>0?1:-1},getRelativePosition:function(t,e){return D.getDirection(e.originVertex.pos,e.destinationVertex.pos,t)},getRelativePosition2:function(t,e){return void 0===e?(console.log("error no eUp"),0):D.Orient2d(e.originVertex.pos,e.destinationVertex.pos,t)},Orient2d:function(t,e,s){let i=(t.x-s.x)*(e.y-s.y)-(t.y-s.y)*(e.x-s.x);return i>-1e-4&&i<h?0:i>0?-1:1},isInFace:function(t,e){let s={type:3};if(null===e)return s;let i=e.edge,n=i.nextLeftEdge,r=n.nextLeftEdge;if(D.getRelativePosition(t,i)>=0&&D.getRelativePosition(t,n)>=0&&D.getRelativePosition(t,r)>=0){let o=i.originVertex,a=n.originVertex,l=r.originVertex,d=o.pos.x,g=o.pos.y,u=a.pos.x,p=a.pos.y,c=l.pos.x,x=l.pos.y,f=E(d-t.x,g-t.y),_=E(u-t.x,p-t.y),m=E(c-t.x,x-t.y),y=1/E(u-d,p-g),w=1/E(c-u,x-p),C=1/E(d-c,g-x),S=(t.x-d)*(u-d)+(t.y-g)*(p-g),F=(t.x-u)*(c-u)+(t.y-p)*(x-p),V=(t.x-c)*(d-c)+(t.y-x)*(g-x),P=_-F*F*w<=h,v=m-V*V*C<=h;s=f-S*S*y<=h?v?o:P?a:i:P?v?l:n:v?r:e}return s},clipSegmentByTriangle:function(t,e,s,i,h,r,o){let a=D.getDirection(s,i,t),l=D.getDirection(s,i,e);if(a<=0&&l<=0)return!1;let d=D.getDirection(i,h,t),g=D.getDirection(i,h,e);if(d<=0&&g<=0)return!1;let u=D.getDirection(h,s,t),p=D.getDirection(h,s,e);if(u<=0&&p<=0)return!1;if(a>=0&&d>=0&&u>=0&&l>=0&&g>=0&&p>=0)return r=t.clone(),o=e.clone(),!0;let c=0;return D.intersections2segments(t,e,s,i,r,null)&&c++,0==c?D.intersections2segments(t,e,i,h,r,null)&&c++:D.intersections2segments(t,e,i,h,o,null)&&(-.01>r.x-o.x||r.x-o.x>n||-.01>r.y-o.y||r.y-o.y>n)&&c++,0==c?D.intersections2segments(t,e,h,s,r,null)&&c++:1==c&&D.intersections2segments(t,e,h,s,o,null)&&(-.01>r.x-o.x||r.x-o.x>n||-.01>r.y-o.y||r.y-o.y>n)&&c++,1==c&&(a>=0&&d>=0&&u>=0?o=t.clone():l>=0&&g>=0&&p>=0?o=e.clone():c=0),c>0},isDelaunay:function(t){let e=t.originVertex,s=t.destinationVertex,i=t.nextLeftEdge.destinationVertex,n=t.nextRightEdge.destinationVertex;D.getCircumcenter(i.pos,e.pos,s.pos,D.__circumcenter);let h=(i.pos.x-D.__circumcenter.x)*(i.pos.x-D.__circumcenter.x)+(i.pos.y-D.__circumcenter.y)*(i.pos.y-D.__circumcenter.y);return(n.pos.x-D.__circumcenter.x)*(n.pos.x-D.__circumcenter.x)+(n.pos.y-D.__circumcenter.y)*(n.pos.y-D.__circumcenter.y)>=h},getCircumcenter:function(t,e,s,i){null==i&&(i=new p);let n=.5*(t.x+e.x),h=.5*(t.y+e.y),r=.5*(t.x+s.x),o=.5*(t.y+s.y),a=(n*(t.x-s.x)+(h-o)*(t.y-s.y)+r*(s.x-t.x))/(t.x*(s.y-e.y)+e.x*(t.y-s.y)+s.x*(e.y-t.y));return i.x=n+a*(e.y-t.y),i.y=h-a*(e.x-t.x),i},intersections2segments:function(t,e,s,i,n,h,r){null==r&&(r=!1);let o,a=0,l=0,d=(t.x-e.x)*(s.y-i.y)+(e.y-t.y)*(s.x-i.x);if(0==d)o=!1;else{o=!0;let g=1/d;r&&null==n&&null==h||(a=(t.x*(s.y-i.y)+t.y*(i.x-s.x)+s.x*i.y-s.y*i.x)*g,l=(t.x*(s.y-e.y)+t.y*(e.x-s.x)-e.x*s.y+e.y*s.x)*g,r||0<=a&&a<=1&&0<=l&&l<=1||(o=!1))}return o&&(null!=n&&(n.x=t.x+a*(e.x-t.x),n.y=t.y+a*(e.y-t.y)),null!=h&&h.push(a,l)),o},intersections2edges:function(t,e,s,i,n){return null==n&&(n=!1),D.intersections2segments(t.originVertex.pos,t.destinationVertex.pos,e.originVertex.pos,e.destinationVertex.pos,s,i,n)},isConvex:function(t){let e,s,i=!0;return e=t.nextLeftEdge.oppositeEdge,s=t.nextRightEdge.destinationVertex,-1!=D.getRelativePosition(s.pos,e)?i=!1:(e=t.prevRightEdge,s=t.prevLeftEdge.originVertex,-1!=D.getRelativePosition(s.pos,e)&&(i=!1)),i},projectOrthogonaly:function(t,e){let s=e.originVertex.pos.x,i=e.originVertex.pos.y,n=e.destinationVertex.pos.x,h=e.destinationVertex.pos.y,r=t.x,o=t.y,a=(s*s-s*n-s*r+i*i-i*h-i*o+n*r+h*o)/(s*s-2*s*n+i*i-2*i*h+n*n+h*h);t.x=s+a*(n-s),t.y=i+a*(h-i)},intersections2Circles:function(t,e,s,i,n){let h,r,o,a,l,d,g;return l=E(s.x-t.x,s.y-t.y),d=1/(2*l),(t.x!=s.x||t.y!=s.y)&&l<=(e+i)*(e+i)&&l>=(e-i)*(e-i)&&(g=Math.sqrt(((e+i)*(e+i)-l)*(l-(i-e)*(i-e))),h=s.clone().sub(t).mul(d),r=t.clone().add(s).mul(.5),o=h.clone().mul(e*e-i*i),a=r.clone().add(o),null!=n&&n.push(a.x+h.y*g,a.y-h.x*g,a.x-h.y*g,a.y+h.x*g),!0)},intersectionsSegmentCircle:function(t,e,s,i,n){let h,r,o,a=t.x*t.x,l=t.y*t.y,d=e.y*e.y-2*e.y*t.y+l+e.x*e.x-2*e.x*t.x+a,g=2*t.y*s.y-2*a+2*e.y*t.y-2*l+2*e.x*t.x-2*e.x*s.x+2*t.x*s.x-2*e.y*s.y,u=g*g-4*d*(l+s.y*s.y+s.x*s.x-2*t.y*s.y-2*t.x*s.x+a-i*i);if(u<0)return!1;if(0==u)return r=-g/(2*d),!(r<0||r>1)&&(null!=n&&n.push(t.x+r*(e.x-t.x),t.y+r*(e.y-t.y),r),!0);{h=Math.sqrt(u),r=(-g+h)/(2*d),o=(-g-h)/(2*d);let s=!1;return 0<=r&&r<=1&&(null!=n&&n.push(t.x+r*(e.x-t.x),t.y+r*(e.y-t.y),r),s=!0),0<=o&&o<=1&&(null!=n&&n.push(t.x+o*(e.x-t.x),t.y+o*(e.y-t.y),o),s=!0),s}},tangentsPointToCircle:function(t,e,s,i){let n=t.clone().add(e).mul(.5),h=.5*_(t.x-e.x,t.y-e.y);return D.intersections2Circles(n,h,e,s,i)},tangentsCrossCircleToCircle:function(t,e,s,i){let n=_(e.x-s.x,e.y-s.y),h=.25*n,r=s.clone().sub(e).mul(.25).add(e);if(D.intersections2Circles(e,t,r,h,i)){let t=i[0],h=i[1],r=i[2],o=i[3],a=e.clone().add(s).mul(.5),l=((t-a.x)*(s.y-e.y)+(h-a.y)*(-s.x+e.x))/(n*n),d=2*(a.x+l*(s.y-e.y))-t,g=2*(a.y-l*(s.x-e.x))-h,u=d+r-t,p=o+g-h;return i.push(u,p,d,g),!0}return!1},tangentsParalCircleToCircle:function(t,e,s,i){let n=1/_(e.x-s.x,e.y-s.y),h=e.x+t*(s.y-e.y)*n,r=e.y+t*(-s.x+e.x)*n,o=2*e.x-h,a=2*e.y-r,l=o+s.x-e.x,d=a+s.y-e.y,g=h+s.x-e.x,u=r+s.y-e.y;i.push(h,r,o,a,l,d,g,u)},distanceSquaredPointToSegment:function(t,e,s){let i=E(s.x-e.x,s.y-e.y),n=((t.x-e.x)*(s.x-e.x)+(t.y-e.y)*(s.y-e.y))/i;if(n<0)return E(t.x-e.x,t.y-e.y);if(n<=1){return E(e.x-t.x,e.y-t.y)-n*n*i}return E(t.x-s.x,t.y-s.y)},distanceSquaredVertexToEdge:function(t,e){return D.distanceSquaredPointToSegment(t.pos,e.originVertex.pos,e.destinationVertex.pos)},pathLength:function(t){let e,s,i,n,h,r=0,o=t[0],a=t[1],l=2,d=t.length;for(;l<d;)e=t[l],s=t[l+1],i=e-o,n=s-a,h=_(i,n),r+=h,o=e,a=s,l+=2;return r}};class L{constructor(){this.type=1,this.id=l.get("edge"),this.fromConstraintSegments=[],this.isConstrained=!1,this.isReal=!1,this.originVertex=null,this.oppositeEdge=null,this.nextLeftEdge=null,this.leftFace=null}get destinationVertex(){return this.oppositeEdge.originVertex}get nextRightEdge(){return this.oppositeEdge.nextLeftEdge.nextLeftEdge.oppositeEdge}get prevRightEdge(){return this.oppositeEdge.nextLeftEdge.oppositeEdge}get prevLeftEdge(){return this.nextLeftEdge.nextLeftEdge}get rotLeftEdge(){return this.nextLeftEdge.nextLeftEdge.oppositeEdge}get rotRightEdge(){return this.oppositeEdge.nextLeftEdge}get rightFace(){return this.oppositeEdge.leftFace}setDatas(t,e,s,i,n,h){this.isConstrained=void 0!==n&&h,this.isReal=void 0===n||n,this.originVertex=t,this.oppositeEdge=e,this.nextLeftEdge=s,this.leftFace=i}getDatas(){return[this.originVertex.pos.x,this.originVertex.pos.y,this.destinationVertex.pos.x,this.destinationVertex.pos.y,this.isConstrained?1:0]}addFromConstraintSegment(t){-1===this.fromConstraintSegments.indexOf(t)&&this.fromConstraintSegments.push(t)}removeFromConstraintSegment(t){const e=this.fromConstraintSegments.indexOf(t);-1!==e&&this.fromConstraintSegments.splice(e,1)}dispose(){this.originVertex=null,this.oppositeEdge=null,this.nextLeftEdge=null,this.leftFace=null,this.fromConstraintSegments=null}toString(){return"edge "+this.originVertex.id+" - "+this.destinationVertex.id}}class T{constructor(){this.type=2,this.id=l.get("face"),this.isReal=!1,this.edge=null}setDatas(t,e){this.isReal=void 0===e||e,this.edge=t}dispose(){this.edge=null,this.isReal=!1}}class M{constructor(){this.type=0,this.id=l.get("vertex"),this.pos=new p,this.fromConstraintSegments=[],this.edge=null,this.isReal=!1}setDatas(t,e){this.isReal=void 0===e||e,this.edge=t}addFromConstraintSegment(t){-1===this.fromConstraintSegments.indexOf(t)&&this.fromConstraintSegments.push(t)}removeFromConstraintSegment(t){const e=this.fromConstraintSegments.indexOf(t);-1!==e&&this.fromConstraintSegments.splice(e,1)}dispose(){this.pos=null,this.edge=null,this.fromConstraintSegments=null}toString(){return"ver_id "+this.id}}class N{constructor(){this.id=l.get("shape"),this.segments=[]}dispose(){for(;this.segments.length>0;)this.segments.pop().dispose();this.segments=null}}class O{constructor(t,e){this.id=l.get("segment"),this.edges=[],this.fromShape=null}addEdge(t){-1===this.edges.indexOf(t)&&-1===this.edges.indexOf(t.oppositeEdge)&&this.edges.push(t)}removeEdge(t){const e=this.edges.indexOf(t);-1===e&&(e=this.edges.indexOf(t.oppositeEdge)),-1!==e&&this.edges.splice(e,1)}dispose(){this.edges=null,this.fromShape=null}toString(){return"seg_id "+this.id}}class R{constructor(){this.id=l.get("object2D"),this._pivot=new p,this._position=new p,this._scale=new p(1,1),this._matrix=new c,this._rotation=0,this._constraintShape=null,this._coordinates=[],this.hasChanged=!1}get rotation(){return this._rotation}set rotation(t){this._rotation!==t&&(this._rotation=t,this.hasChanged=!0)}get matrix(){return this._matrix}set matrix(t){this._rotation!==t&&(this._rotation=t,this.hasChanged=!0)}get coordinates(){return this._coordinates}set coordinates(t){this._coordinates=t,this.hasChanged=!0}get constraintShape(){return this._constraintShape}set constraintShape(t){this._constraintShape=t,this.hasChanged=!0}get edges(){let t,e=[],s=this._constraintShape.segments,i=s.length,n=0,h=0,r=0,o=0;for(;n<i;)for(r=n++,h=0,t=s[r].edges.length;h<t;)o=h++,e.push(s[r].edges[o]);return e}position(t,e){this._position.set(t,e),this.hasChanged=!0}scale(t,e){this._scale.set(t,e),this.hasChanged=!0}pivot(t,e){this._pivot.set(t,e),this.hasChanged=!0}dispose(){this._matrix=null,this._coordinates=null,this._constraintShape=null}updateValuesFromMatrix(){}updateMatrixFromValues(){this._matrix.identity().translate(this._pivot.negate()).scale(this._scale).rotate(this._rotation).translate(this._position)}}class k{constructor(){this.id=l.get("graph"),this.edge=null,this.node=null}dispose(){for(;null!==this.node;)this.deleteNode(this.node)}insertNode(){let t=new j;return null!=this.node&&(t.next=this.node,this.node.prev=t),this.node=t,t}deleteNode(t){for(;null!=t.outgoingEdge;)null!=t.outgoingEdge.oppositeEdge&&this.deleteEdge(t.outgoingEdge.oppositeEdge),this.deleteEdge(t.outgoingEdge);let e,s=this.node;for(;null!=s;)e=s.successorNodes.get(t),null!=e&&this.deleteEdge(e),s=s.next;this.node==t?null!=t.next?(t.next.prev=null,this.node=t.next):this.node=null:null!=t.next?(t.prev.next=t.next,t.next.prev=t.prev):t.prev.next=null,t.dispose()}insertEdge(t,e){if(null!=t.successorNodes.get(e))return null;let s=new I;null!=this.edge&&(this.edge.prev=s,s.next=this.edge),this.edge=s,s.sourceNode=t,s.destinationNode=e,t.successorNodes.set(e,s),null!=t.outgoingEdge?(t.outgoingEdge.rotPrevEdge=s,s.rotNextEdge=t.outgoingEdge,t.outgoingEdge=s):t.outgoingEdge=s;let i=e.successorNodes.get(t);return null!==i&&(s.oppositeEdge=i,i.oppositeEdge=s),s}deleteEdge(t){this.edge==t?null!=t.next?(t.next.prev=null,this.edge=t.next):this.edge=null:null!=t.next?(t.prev.next=t.next,t.next.prev=t.prev):t.prev.next=null,t.sourceNode.outgoingEdge==t?null!=t.rotNextEdge?(t.rotNextEdge.rotPrevEdge=null,t.sourceNode.outgoingEdge=t.rotNextEdge):t.sourceNode.outgoingEdge=null:null!=t.rotNextEdge?(t.rotPrevEdge.rotNextEdge=t.rotNextEdge,t.rotNextEdge.rotPrevEdge=t.rotPrevEdge):t.rotPrevEdge.rotNextEdge=null,t.dispose()}}class I{constructor(){this.id=l.get("graphEdge"),this.next=null,this.prev=null,this.rotPrevEdge=null,this.rotNextEdge=null,this.oppositeEdge=null,this.sourceNode=null,this.destinationNode=null,this.data=null}dispose(){this.next=null,this.prev=null,this.rotPrevEdge=null,this.rotNextEdge=null,this.oppositeEdge=null,this.sourceNode=null,this.destinationNode=null,this.data=null}}class j{constructor(){this.id=l.get("graphNode"),this.successorNodes=new u(1),this.prev=null,this.next=null,this.outgoingEdge=null,this.data=null}dispose(){this.successorNodes.dispose(),this.prev=null,this.next=null,this.outgoingEdge=null,this.successorNodes=null,this.data=null}}function A(){}function q(){}const B={color:{r:255,g:255,b:255},nearly:50,maxDistance:1,setColor:function(t){B.color=t},setNearly:function(t){B.nearly=t},buildShapes:function(t){let e=[],s=new u(2),i=t.height-1,n=t.width-1;for(let h=1;h<i;h++)for(let i=0;i<n;i++)B.getWhite(t,i,h)&&!B.getWhite(t,i+1,h)&&(s.get(i+1+"_"+h)||e.push(B.buildShape(t,h,i+1,s)));return s.dispose(),e},getWhite:function(t,e,s){let i=!1,n=t.bytes,h=t.width,r=B.color,o=B.nearly,a=e+s*h<<2;return void 0!==r.r&&m(n[a],r.r,o)&&(i=!0),void 0!==r.g&&m(n[a+1],r.g,o)&&(i=!0),void 0!==r.b&&m(n[a+2],r.b,o)&&(i=!0),void 0!==r.a&&m(n[a+3],r.a,o)&&(i=!0),i},buildShape:function(t,e,s,i){let n=s,h=e,r=[n,h];i.set(n+"_"+h,!0),t.width,t.height;let o,a,l=new p(0,1),d=new p,g=-1;for(;!(o=e+l.x+l.y,a=s+l.x-l.y,B.getWhite(t,a,o)?(o=e+l.y,a=s+l.x,B.getWhite(t,a,o)?(o=e,a=s,d.x=l.y,d.y=-l.x):(d.x=l.x,d.y=l.y)):(d.x=-l.y,d.y=l.x),n+=l.x,h+=l.y,n===r[0]&&h===r[1]||(r.push(n),r.push(h),i.set(n+"_"+h,!0),e=o,s=a,l.x=d.x,l.y=d.y,g--,0===g)););return r},buildGraph:function(t){let e,s,i,n,h,r,o,a=0,l=new k;for(;a<t.length;)e=l.insertNode(),e.data=new q,e.data.index=a,e.data.point=new p(t[a],t[a+1]),a+=2;let d,g,u=!1;for(s=l.node;null!=s;){for(i=null!=s.next?s.next:l.node;i!=s;){for(u=!0,n=null!=s.next?s.next:l.node,o=2,r=0;n!=i;){if(h=D.distanceSquaredPointToSegment(n.data.point,s.data.point,i.data.point),h<0&&(h=0),h>=B.maxDistance){u=!1;break}o++,r+=h,n=null!=n.next?n.next:l.node}if(!u)break;d=l.insertEdge(s,i),g=new A,g.sumDistancesSquared=r,g.length=s.data.point.distanceTo(i.data.point),g.nodesCount=o,d.data=g,i=null!=i.next?i.next:l.node}s=s.next}return l},buildPolygon:function(t){let e,s,i,n,h,r,o=[],a=2147483647,l=null,d=t.node;for(;d.data.index<a;){for(a=d.data.index,o.push(d.data.point.x),o.push(d.data.point.y),r=0,n=d.outgoingEdge;null!=n;)h=n.data.nodesCount-n.data.length*Math.sqrt(n.data.sumDistancesSquared/n.data.nodesCount),h>r&&(r=h,l=n),n=n.rotNextEdge;d=l.destinationNode}return e=new p(o[o.length-2],o[o.length-1]),s=new p(o[0],o[1]),i=new p(o[2],o[3]),0===D.getDirection(e,s,i)&&(o.shift(),o.shift()),o}};class W{constructor(t,e){this.id=l.get("mesh2D"),this.__objectsUpdateInProgress=!1,this.__centerVertex=null,this.width=t,this.height=e,this.clipping=!0,this._edges=[],this._faces=[],this._objects=[],this._vertices=[],this._constraintShapes=[],this.__edgesToCheck=[],this.AR_vertex=null,this.AR_edge=null,this.isRedraw=!0}deDuplicEdge(){let t,e,s,i,n,h,r=this._edges;for(e=r.length;e;)for(i=r[--e],s=r[--e],t=e;t;)if(h=r[--t],n=r[--t],s===n&&i===h||s===h&&i===n){r.splice(e,2),r.splice(t,2);break}}clear(t){for(;this._vertices.length>0;)this._vertices.pop().dispose();for(this._vertices=[];this._edges.length>0;)this._edges.pop().dispose();for(this._edges=[];this._faces.length>0;)this._faces.pop().dispose();for(this._faces=[];this._constraintShapes.length>0;)this._constraintShapes.pop().dispose();if(this._constraintShapes=[],!t)for(;this._objects.length>0;)this._objects.pop().dispose();this._objects=[],this.__edgesToCheck=[],this.__centerVertex=[],this.AR_vertex=null,this.AR_edge=null}dispose(){for(;this._vertices.length>0;)this._vertices.pop().dispose();for(this._vertices=null;this._edges.length>0;)this._edges.pop().dispose();for(this._edges=null;this._faces.length>0;)this._faces.pop().dispose();for(this._faces=null;this._constraintShapes.length>0;)this._constraintShapes.pop().dispose();for(this._constraintShapes=null;this._objects.length>0;)this._objects.pop().dispose();this._objects=null,this.__edgesToCheck=null,this.__centerVertex=null,this.AR_vertex=null,this.AR_edge=null}buildFromRecord(t){let e=t.split(";"),s=e.length,i=0;for(;i<s;)this.insertConstraintSegment(parseFloat(e[i]),parseFloat(e[i+1]),parseFloat(e[i+2]),parseFloat(e[i+3])),i+=4}insertObject(t){null!=t.constraintShape&&this.deleteObject(t);let e,s=new N,i=t.coordinates;t.updateMatrixFromValues();let n=t.matrix||new c,h=new p,r=new p,o=i.length,a=0;for(a=0;a<o;a+=4)h.set(i[a],i[a+1]).transformMat2D(n),r.set(i[a+2],i[a+3]).transformMat2D(n),e=this.insertConstraintSegment(h.x,h.y,r.x,r.y),null!=e&&(e.fromShape=s,s.segments.push(e));this._constraintShapes.push(s),t.constraintShape=s,this.__objectsUpdateInProgress||this._objects.push(t)}deleteObject(t){if(null!=t.constraintShape&&(this.deleteConstraintShape(t.constraintShape),t.constraintShape=null,!this.__objectsUpdateInProgress)){let e=this._objects.indexOf(t);this._objects.splice(e,1)}}updateObjects(){this.__objectsUpdateInProgress=!0;let t,e=this._objects.length,s=0;for(;s<e;)t=this._objects[s],t.hasChanged&&(this.deleteObject(t),this.insertObject(t),t.hasChanged=!1,this.isRedraw=!0),s++;this.__objectsUpdateInProgress=!1}insertConstraintShape(t){let e=new N,s=null,i=t.length,n=0;for(;n<i;)s=this.insertConstraintSegment(t[n],t[n+1],t[n+2],t[n+3]),null!=s&&(s.fromShape=e,e.segments.push(s)),n+=4;return this._constraintShapes.push(e),e}deleteConstraintShape(t){let e=0,s=t.segments.length;for(;e<s;)this.deleteConstraintSegment(t.segments[e]),e++;this._constraintShapes.splice(this._constraintShapes.indexOf(t),1),t.dispose()}insertConstraintSegment(t,e,s,i){let n=t,o=e,a=s,l=i;if(t>this.width&&s>this.width||t<0&&s<0||e>this.height&&i>this.height||e<0&&i<0)return null;{let h=s-t,d=i-e,g=-1/0,u=r;if(0!=h){let e=(0-t)/h,s=(this.width-t)/h;g=Math.max(g,Math.min(e,s)),u=Math.min(u,Math.max(e,s))}if(0!=d){let t=(0-e)/d,s=(this.height-e)/d;g=Math.max(g,Math.min(t,s)),u=Math.min(u,Math.max(t,s))}if(!(u>=g))return null;u<1&&(a=h*u+t,l=d*u+e),g>0&&(n=h*g+t,o=d*g+e)}let d=this.insertVertex(n,o);if(null==d)return null;let u=this.insertVertex(a,l);if(null==u)return null;if(d.id===u.id)return null;let c,x,f=new b,_=new O,m=new L,y=new L;m.setDatas(d,y,null,null,!0,!0),y.setDatas(u,m,null,null,!0,!0);let E,w,C,S=[],F=[],V=[],P={type:3},v=new p,T=!1;for(c=d,P=c;;)if(T=!1,0===P.type){for(c=P,f.fromVertex=c;null!=(x=f.next());){if(x.destinationVertex.id===u.id)return x.isConstrained||(x.isConstrained=!0,x.oppositeEdge.isConstrained=!0),x.addFromConstraintSegment(_),x.oppositeEdge.fromConstraintSegments=x.fromConstraintSegments,d.addFromConstraintSegment(_),u.addFromConstraintSegment(_),_.addEdge(x),_;if(D.distanceSquaredVertexToEdge(x.destinationVertex,m)<=h){x.isConstrained||(x.isConstrained=!0,x.oppositeEdge.isConstrained=!0),x.addFromConstraintSegment(_),x.oppositeEdge.fromConstraintSegments=x.fromConstraintSegments,d.addFromConstraintSegment(_),_.addEdge(x),d=x.destinationVertex,m.originVertex=d,P=d,T=!0;break}}if(T)continue;for(f.fromVertex=c;null!=(x=f.next());)if(x=x.nextLeftEdge,D.intersections2edges(x,m,v)){if(x.isConstrained){for(d=this.splitEdge(x,v.x,v.y),f.fromVertex=c;null!=(x=f.next());)if(x.destinationVertex.id===d.id){x.isConstrained=!0,x.oppositeEdge.isConstrained=!0,x.addFromConstraintSegment(_),x.oppositeEdge.fromConstraintSegments=x.fromConstraintSegments,_.addEdge(x);break}c.addFromConstraintSegment(_),m.originVertex=d,P=d}else S.push(x),F.unshift(x.nextLeftEdge),V.push(x.prevLeftEdge),x=x.oppositeEdge,P=x;break}}else{if(1!==P.type)return g("not finding"),null;if(x=P,E=x.nextLeftEdge,E.destinationVertex.id===u.id)return F.unshift(E.nextLeftEdge),V.push(E),w=new L,C=new L,w.setDatas(d,C,null,null,!0,!0),C.setDatas(u,w,null,null,!0,!0),F.push(w),V.push(C),this.insertNewConstrainedEdge(_,w,S,F,V),_;if(D.distanceSquaredVertexToEdge(E.destinationVertex,m)<=h)F.unshift(E.nextLeftEdge),V.push(E),w=new L,C=new L,w.setDatas(d,C,null,null,!0,!0),C.setDatas(E.destinationVertex,w,null,null,!0,!0),F.push(w),V.push(C),this.insertNewConstrainedEdge(_,w,S,F,V),S.splice(0,S.length),F.splice(0,F.length),V.splice(0,V.length),d=E.destinationVertex,m.originVertex=d,P=d;else if(D.intersections2edges(E,m,v))if(E.isConstrained){for(c=this.splitEdge(E,v.x,v.y),f.fromVertex=c;null!=(x=f.next());)x.destinationVertex==F[0].originVertex&&F.unshift(x),x.destinationVertex==V[V.length-1].destinationVertex&&V.push(x.oppositeEdge);w=new L,C=new L,w.setDatas(d,C,null,null,!0,!0),C.setDatas(c,w,null,null,!0,!0),F.push(w),V.push(C),this.insertNewConstrainedEdge(_,w,S,F,V),S.splice(0,S.length),F.splice(0,F.length),V.splice(0,V.length),d=c,m.originVertex=d,P=d}else S.push(E),F.unshift(E.nextLeftEdge),x=E.oppositeEdge,P=x;else if(E=E.nextLeftEdge,D.intersections2edges(E,m,v),E.isConstrained){for(c=this.splitEdge(E,v.x,v.y),f.fromVertex=c;null!=(x=f.next());)x.destinationVertex.id===F[0].originVertex.id&&F.unshift(x),x.destinationVertex.id===V[V.length-1].destinationVertex.id&&V.push(x.oppositeEdge);w=new L,C=new L,w.setDatas(d,C,null,null,!0,!0),C.setDatas(c,w,null,null,!0,!0),F.push(w),V.push(C),this.insertNewConstrainedEdge(_,w,S,F,V),S.splice(0,S.length),F.splice(0,F.length),V.splice(0,V.length),d=c,m.originVertex=d,P=d}else S.push(E),V.push(E.prevLeftEdge),x=E.oppositeEdge,P=x}}insertNewConstrainedEdge(t,e,s,i,n){this._edges.push(e),this._edges.push(e.oppositeEdge),e.addFromConstraintSegment(t),e.oppositeEdge.fromConstraintSegments=e.fromConstraintSegments,t.addEdge(e),e.originVertex.addFromConstraintSegment(t),e.destinationVertex.addFromConstraintSegment(t),this.untriangulate(s),this.triangulate(i,!0),this.triangulate(n,!0)}deleteConstraintSegment(t){let e,s=[],i=null,n=t.edges.length,h=0;for(;h<n;)i=t.edges[h],i.removeFromConstraintSegment(t),0==i.fromConstraintSegments.length&&(i.isConstrained=!1,i.oppositeEdge.isConstrained=!1),e=i.originVertex,e.removeFromConstraintSegment(t),s.push(e),h++;for(e=i.destinationVertex,e.removeFromConstraintSegment(t),s.push(e),n=s.length,h=0;h<n;)this.deleteVertex(s[h]),h++;t.dispose()}check(){let t=this._edges.length,e=0;for(;e<t;){if(null==this._edges[e].nextLeftEdge)return void g("!!! missing nextLeftEdge");e++}g("check OK")}insertVertex(t,e){if(t<0||e<0||t>this.width||e>this.height)return null;this.__edgesToCheck.splice(0,this.__edgesToCheck.length);let s=D.locatePosition(new p(t,e),this),i=null;switch(s.type){case 0:i=s;break;case 1:let n=s;i=this.splitEdge(n,t,e);break;case 2:let h=s;i=this.splitFace(h,t,e)}return this.restoreAsDelaunay(),i}flipEdge(t){let e=t,s=t.oppositeEdge,i=new L,n=new L,h=e.nextLeftEdge,r=h.nextLeftEdge,o=s.nextLeftEdge,a=o.nextLeftEdge,l=e.originVertex,d=s.originVertex,g=r.originVertex,u=a.originVertex,p=e.leftFace,c=s.leftFace,x=new T,f=new T;return this._edges.push(i),this._edges.push(n),this._faces.push(f),this._faces.push(x),i.setDatas(g,n,a,f,t.isReal,t.isConstrained),n.setDatas(u,i,r,x,t.isReal,t.isConstrained),f.setDatas(i),x.setDatas(n),d.edge.id===s.id&&d.setDatas(h),l.edge.id===e.id&&l.setDatas(o),h.nextLeftEdge=i,h.leftFace=f,r.nextLeftEdge=o,r.leftFace=x,o.nextLeftEdge=n,o.leftFace=x,a.nextLeftEdge=h,a.leftFace=f,this._edges.splice(this._edges.indexOf(e),1),this._edges.splice(this._edges.indexOf(s),1),e.dispose(),s.dispose(),this._faces.splice(this._faces.indexOf(p),1),this._faces.splice(this._faces.indexOf(c),1),p.dispose(),c.dispose(),n}splitEdge(t,e,s){this.__edgesToCheck.splice(0,this.__edgesToCheck.length);let i=t,n=i.oppositeEdge,r=i.nextLeftEdge,o=r.nextLeftEdge,a=n.nextLeftEdge,l=a.nextLeftEdge,d=o.originVertex,g=i.originVertex,u=l.originVertex,p=n.originVertex,c=i.leftFace,x=n.leftFace;if((g.pos.x-e)*(g.pos.x-e)+(g.pos.y-s)*(g.pos.y-s)<=h)return g;if((p.pos.x-e)*(p.pos.x-e)+(p.pos.y-s)*(p.pos.y-s)<=h)return p;let f=new M,_=new L,m=new L,y=new L,E=new L,w=new L,C=new L,S=new L,F=new L,V=new T,P=new T,v=new T,b=new T;if(this._vertices.push(f),this._edges.push(m),this._edges.push(_),this._edges.push(C),this._edges.push(w),this._edges.push(E),this._edges.push(y),this._edges.push(F),this._edges.push(S),this._faces.push(b),this._faces.push(v),this._faces.push(P),this._faces.push(V),f.setDatas(c.isReal?m:E),f.pos.x=e,f.pos.y=s,D.projectOrthogonaly(f.pos,i),m.setDatas(f,_,o,V,c.isReal),_.setDatas(d,m,F,b,c.isReal),C.setDatas(f,w,a,P,t.isReal,t.isConstrained),w.setDatas(g,C,m,V,t.isReal,t.isConstrained),E.setDatas(f,y,l,v,x.isReal),y.setDatas(u,E,C,P,x.isReal),F.setDatas(f,S,r,b,t.isReal,t.isConstrained),S.setDatas(p,F,E,v,t.isReal,t.isConstrained),V.setDatas(m,c.isReal),P.setDatas(C,x.isReal),v.setDatas(E,x.isReal),b.setDatas(F,c.isReal),g.edge.id===i.id&&g.setDatas(w),p.edge.id===n.id&&p.setDatas(S),o.nextLeftEdge=w,o.leftFace=V,a.nextLeftEdge=y,a.leftFace=P,l.nextLeftEdge=S,l.leftFace=v,r.nextLeftEdge=_,r.leftFace=b,i.isConstrained){let t,e,s=i.fromConstraintSegments;w.fromConstraintSegments=s.slice(0),C.fromConstraintSegments=w.fromConstraintSegments,F.fromConstraintSegments=s.slice(0),S.fromConstraintSegments=F.fromConstraintSegments;let h=i.fromConstraintSegments.length,r=0;for(;r<h;)t=i.fromConstraintSegments[r].edges,e=t.indexOf(i),-1!=e?t.splice(e,1,w,F):t.splice(t.indexOf(n),1,S,C),r++;f.fromConstraintSegments=s.slice(0)}return this._edges.splice(this._edges.indexOf(i),1),this._edges.splice(this._edges.indexOf(n),1),i.dispose(),n.dispose(),this._faces.splice(this._faces.indexOf(c),1),this._faces.splice(this._faces.indexOf(x),1),c.dispose(),x.dispose(),this.__centerVertex=f,this.__edgesToCheck.push(o),this.__edgesToCheck.push(a),this.__edgesToCheck.push(l),this.__edgesToCheck.push(r),f}splitFace(t,e,s){this.__edgesToCheck.splice(0,this.__edgesToCheck.length);let i=t.edge,n=i.nextLeftEdge,h=n.nextLeftEdge,r=i.originVertex,o=n.originVertex,a=h.originVertex,l=new M,d=new L,g=new L,u=new L,p=new L,c=new L,x=new L,f=new T,_=new T,m=new T;return this._vertices.push(l),this._edges.push(d),this._edges.push(g),this._edges.push(u),this._edges.push(p),this._edges.push(c),this._edges.push(x),this._faces.push(f),this._faces.push(_),this._faces.push(m),l.setDatas(g),l.pos.x=e,l.pos.y=s,d.setDatas(r,g,x,m),g.setDatas(l,d,i,f),u.setDatas(o,p,g,f),p.setDatas(l,u,n,_),c.setDatas(a,x,p,_),x.setDatas(l,c,h,m),f.setDatas(g),_.setDatas(p),m.setDatas(x),i.nextLeftEdge=u,i.leftFace=f,n.nextLeftEdge=c,n.leftFace=_,h.nextLeftEdge=d,h.leftFace=m,this._faces.splice(this._faces.indexOf(t),1),t.dispose(),this.__centerVertex=l,this.__edgesToCheck.push(i),this.__edgesToCheck.push(n),this.__edgesToCheck.push(h),l}restoreAsDelaunay(){let t;for(;this.__edgesToCheck.length>0;)t=this.__edgesToCheck.shift(),!t.isReal||t.isConstrained||D.isDelaunay(t)||(t.nextLeftEdge.destinationVertex.id===this.__centerVertex.id?(this.__edgesToCheck.push(t.nextRightEdge),this.__edgesToCheck.push(t.prevRightEdge)):(this.__edgesToCheck.push(t.nextLeftEdge),this.__edgesToCheck.push(t.prevLeftEdge)),this.flipEdge(t))}deleteVertex(t){let e,s,i=new b;i.fromVertex=t,i.realEdgesOnly=!1;let n=[];e=0==t.fromConstraintSegments.length;let h,r=[],o=!1,a=!1,l=[],d=[];if(e)for(;null!=(s=i.next());)n.push(s),r.push(s.nextLeftEdge);else{let e,h=0,r=t.fromConstraintSegments.length;for(;h<r;){let s=h++;if(e=t.fromConstraintSegments[s].edges,e[0].originVertex.id===t.id||e[e.length-1].destinationVertex.id===t.id)return!1}let g=0;for(;null!=(s=i.next());)if(n.push(s),s.isConstrained&&(g++,g>2))return!1;l=[],d=[];let u=null,p=null,c=new L,x=new L;this._edges.push(c),this._edges.push(x);let f,_=0,m=n.length;for(;_<m;){s=n[_++],s.isConstrained?null==u?(x.setDatas(s.destinationVertex,c,null,null,!0,!0),l.push(c),l.push(s.nextLeftEdge),d.push(x),u=s):null==p&&(c.setDatas(s.destinationVertex,x,null,null,!0,!0),d.push(s.nextLeftEdge),p=s):null==u?d.push(s.nextLeftEdge):null==p?l.push(s.nextLeftEdge):d.push(s.nextLeftEdge)}o=u.leftFace.isReal,a=p.leftFace.isReal,c.fromConstraintSegments=u.fromConstraintSegments.slice(0),x.fromConstraintSegments=c.fromConstraintSegments;let y=0,E=t.fromConstraintSegments.length;for(;y<E;){let s=y++;e=t.fromConstraintSegments[s].edges,f=e.indexOf(u),-1!=f?e.splice(f-1,2,c):e.splice(e.indexOf(p)-1,2,x)}}let g=0,u=n.length;for(;g<u;){s=n[g++],h=s.leftFace,this._faces.splice(this._faces.indexOf(h),1),h.dispose(),s.destinationVertex.edge=s.nextLeftEdge,this._edges.splice(this._edges.indexOf(s.oppositeEdge),1),s.oppositeEdge.dispose(),this._edges.splice(this._edges.indexOf(s),1),s.dispose()}return this._vertices.splice(this._vertices.indexOf(t),1),t.dispose(),e?this.triangulate(r,!0):(this.triangulate(l,o),this.triangulate(d,a)),!0}untriangulate(t){let e,s=new u(1),i=0,n=t.length;for(;i<n;){let n=i++;e=t[n],null==s.get(e.originVertex)&&(e.originVertex.edge=e.prevLeftEdge.oppositeEdge,s.set(e.originVertex,!0)),null==s.get(e.destinationVertex)&&(e.destinationVertex.edge=e.nextLeftEdge,s.set(e.destinationVertex,!0)),this._faces.splice(this._faces.indexOf(e.leftFace),1),e.leftFace.dispose(),n==t.length-1&&(this._faces.splice(this._faces.indexOf(e.rightFace),1),e.rightFace.dispose())}s.dispose();let h=0,r=t.length;for(;h<r;){e=t[h++],this._edges.splice(this._edges.indexOf(e.oppositeEdge),1),this._edges.splice(this._edges.indexOf(e),1),e.oppositeEdge.dispose(),e.dispose()}}triangulate(t,e){if(t.length<2)g("BREAK ! the hole has less than 2 edges");else if(2!==t.length)if(3===t.length){let s=new T;s.setDatas(t[0],e),this._faces.push(s),t[0].leftFace=s,t[1].leftFace=s,t[2].leftFace=s,t[0].nextLeftEdge=t[1],t[1].nextLeftEdge=t[2],t[2].nextLeftEdge=t[0]}else{let s,i,n=t[0],r=n.originVertex,o=n.destinationVertex,a=new p,l=0,d=0,u=!1,c=0,x=2,f=t.length;for(;x<f;){let e=x++;if(s=t[e].originVertex,1==D.getRelativePosition2(s.pos,n)){c=e,u=!0,D.getCircumcenter(r.pos,o.pos,s.pos,a),l=E(r.pos.x-a.x,r.pos.y-a.y),l-=h;let n=2,g=t.length;for(;n<g;){let s=n++;if(s!=e&&(i=t[s].originVertex,d=E(i.pos.x-a.x,i.pos.y-a.y),d<l)){u=!1;break}}if(u)break}}u||(g("NO DELAUNAY FOUND"),c=2);let _,m,y,w,C,S,F=[];c<t.length-1&&(_=new L,m=new L,this._edges.push(_,m),_.setDatas(r,m,null,null,e,!1),m.setDatas(t[c].originVertex,_,null,null,e,!1),C=t.slice(c),C.push(_),this.triangulate(C,e)),c>2&&(y=new L,w=new L,this._edges.push(y,w),y.setDatas(t[1].originVertex,w,null,null,e,!1),w.setDatas(t[c].originVertex,y,null,null,e,!1),S=t.slice(1,c),S.push(w),this.triangulate(S,e)),2===c?F.push(n,t[1],m):c===t.length-1?F.push(n,y,t[c]):F.push(n,y,m),this.triangulate(F,e)}else g("BREAK ! the hole has only 2 edges")}findPositionFromBounds(t,e){return t<=0?e<=0?1:e>=this.height?7:8:t>=this.width?e<=0?3:e>=this.height?5:4:e<=0?2:e>=this.height?6:0}compute_Data(){let t,e;this.AR_vertex=[],this.AR_edge=[];let s=new V;s.fromMesh=this;let i=new v,n=new u(1);for(;null!=(t=s.next());)if(n.set(t,!0),this.vertexIsInsideAABB(t,this))for(this.AR_vertex.push(t.pos.x,t.pos.y),i.fromVertex=t;null!=(e=i.next());)n.get(e.originVertex)||(this.AR_edge=this.AR_edge.concat(e.getDatas()));n.dispose()}vertexIsInsideAABB(t,e){return!(t.pos.x<0||t.pos.x>e.width||t.pos.y<0||t.pos.y>e.height)}}class G{constructor(){this.fromFace=null,this.toFace=null,this.curFace=null,this.iterEdge=new F,this.mesh=null,this._radius=0,this.radiusSquared=0,this.diameter=0,this.diameterSquared=0}get radius(){return this._radius}set radius(t){this._radius=t,this.radiusSquared=this._radius*this._radius,this.diameter=2*this._radius,this.diameterSquared=this.diameter*this.diameter}dispose(){this.mesh=null,this.closedFaces.dispose(),this.openedFaces.dispose(),this.entryEdges.dispose(),this.predecessor.dispose(),this.entryX.dispose(),this.entryY.dispose(),this.scoreF.dispose(),this.scoreG.dispose(),this.scoreH.dispose(),this.sortedOpenedFaces=null,this.closedFaces=null,this.openedFaces=null,this.entryEdges=null,this.entryX=null,this.entryY=null,this.scoreF=null,this.scoreG=null,this.scoreH=null,this.predecessor=null}findPath(t,e,s,i){let n;if(this.sortedOpenedFaces=[],this.closedFaces=new u(1),this.openedFaces=new u(1),this.entryEdges=new u(1),this.predecessor=new u(1),this.entryX=new u(1),this.entryY=new u(1),this.scoreF=new u(1),this.scoreG=new u(1),this.scoreH=new u(1),n=D.locatePosition(t,this.mesh),0===n.type)return;if(1===n.type){if(n.isConstrained)return;this.fromFace=n.leftFace}else 2===n.type&&(this.fromFace=n);n=D.locatePosition(e,this.mesh),0===n.type?this.toFace=n.edge.leftFace:1===n.type?this.toFace=n.leftFace:2===n.type&&(this.toFace=n),this.sortedOpenedFaces.push(this.fromFace),this.entryEdges.set(this.fromFace,null),this.entryX.set(this.fromFace,t.x),this.entryY.set(this.fromFace,t.y),this.scoreG.set(this.fromFace,0);const h=_(e.x-t.x,e.y-t.y);let r,o,a,l,d;this.scoreH.set(this.fromFace,h),this.scoreF.set(this.fromFace,h);const c=new p,x=new p,f=new p;let m=!1;for(;;){if(0==this.sortedOpenedFaces.length){g("NO PATH FOUND (AStar)"),this.curFace=null;break}if(this.curFace=this.sortedOpenedFaces.pop(),this.curFace==this.toFace)break;for(this.iterEdge.fromFace=this.curFace;null!=(r=this.iterEdge.next());)if(!r.isConstrained&&(o=r.rightFace,!this.closedFaces.get(o))){if(this.curFace!=this.fromFace&&this._radius>0&&!this.isWalkableByRadius(this.entryEdges.get(this.curFace),this.curFace,r))continue;c.set(this.entryX.get(this.curFace),this.entryY.get(this.curFace)),x.set(.5*(r.originVertex.pos.x+r.destinationVertex.pos.x),.5*(r.originVertex.pos.y+r.destinationVertex.pos.y)),f.copy(x).sub(e),d=f.length(),f.copy(c).sub(x),l=this.scoreG.get(this.curFace)+f.length(),a=d+l,m=!1,null!=this.openedFaces.get(o)&&this.openedFaces.get(o)?this.scoreF.get(o)>a&&(m=!0):(this.sortedOpenedFaces.push(o),this.openedFaces.set(o,!0),m=!0),m&&(this.entryEdges.set(o,r),this.entryX.set(o,x.x),this.entryY.set(o,x.y),this.scoreF.set(o,a),this.scoreG.set(o,l),this.scoreH.set(o,d),this.predecessor.set(o,this.curFace))}this.openedFaces.set(this.curFace,!1),this.closedFaces.set(this.curFace,!0),this.sortedOpenedFaces.sort(function(t,e){return this.scoreF.get(t)==this.scoreF.get(e)?0:this.scoreF.get(t)<this.scoreF.get(e)?1:-1}.bind(this))}if(null!=this.curFace)for(s.push(this.curFace);this.curFace!=this.fromFace;)i.unshift(this.entryEdges.get(this.curFace)),this.curFace=this.predecessor.get(this.curFace),s.unshift(this.curFace)}isWalkableByRadius(t,e,s){let i,n,h,r=null,o=null,a=null;if(t.originVertex==s.originVertex?(r=t.destinationVertex,o=s.destinationVertex,a=t.originVertex):t.destinationVertex==s.destinationVertex?(r=t.originVertex,o=s.originVertex,a=t.destinationVertex):t.originVertex==s.destinationVertex?(r=t.destinationVertex,o=s.originVertex,a=t.originVertex):t.destinationVertex==s.originVertex&&(r=t.originVertex,o=s.destinationVertex,a=t.destinationVertex),i=(a.pos.x-r.pos.x)*(o.pos.x-r.pos.x)+(a.pos.y-r.pos.y)*(o.pos.y-r.pos.y),i<=0)return n=E(a.pos.x-r.pos.x,a.pos.y-r.pos.y),n>=this.diameterSquared;if(i=(a.pos.x-o.pos.x)*(r.pos.x-o.pos.x)+(a.pos.y-o.pos.y)*(r.pos.y-o.pos.y),i<=0)return n=E(a.pos.x-o.pos.x,a.pos.y-o.pos.y),n>=this.diameterSquared;if(h=e.edge!=t&&e.edge.oppositeEdge!=t&&e.edge!=s&&e.edge.oppositeEdge!=s?e.edge:e.edge.nextLeftEdge!=t&&e.edge.nextLeftEdge.oppositeEdge!=t&&e.edge.nextLeftEdge!=s&&e.edge.nextLeftEdge.oppositeEdge!=s?e.edge.nextLeftEdge:e.edge.prevLeftEdge,h.isConstrained){var l=new p(a.pos.x,a.pos.y);return D.projectOrthogonaly(l,h),n=E(l.x-a.pos.x,l.y-a.pos.y),n>=this.diameterSquared}{let t=E(a.pos.x-r.pos.x,a.pos.y-r.pos.y),s=E(a.pos.x-o.pos.x,a.pos.y-o.pos.y);if(t<this.diameterSquared||s<this.diameterSquared)return!1;{let t,s,i,n,r,o,l=[],d=[],g=new u(1);if(d.push(h),h.leftFace==e){l.push(h.rightFace);let t=h.rightFace;g.set(t,!0)}else{l.push(h.leftFace);let t=h.leftFace;g.set(t,!0)}for(;l.length>0;){if(t=l.shift(),s=d.shift(),t.edge==s||t.edge==s.oppositeEdge?(i=t.edge.nextLeftEdge,r=t.edge.nextLeftEdge.nextLeftEdge):t.edge.nextLeftEdge==s||t.edge.nextLeftEdge==s.oppositeEdge?(i=t.edge,r=t.edge.nextLeftEdge.nextLeftEdge):(i=t.edge,r=t.edge.nextLeftEdge),n=i.leftFace==t?i.rightFace:i.leftFace,o=r.leftFace==t?r.rightFace:r.leftFace,!g.get(n)&&D.distanceSquaredVertexToEdge(a,i)<this.diameterSquared){if(i.isConstrained)return!1;l.push(n),d.push(i),g.set(n,!0)}if(!g.get(o)&&D.distanceSquaredVertexToEdge(a,r)<this.diameterSquared){if(r.isConstrained)return!1;l.push(o),d.push(r),g.set(o,!0)}}return g.dispose(),!0}}}}class X{constructor(){this._currPoolPointsIndex=0,this._poolPointsSize=3e3,this._numSamplesCircle=16,this._radiusSquared=0,this._radius=0,this._poolPoints=[];let t=this._poolPointsSize,e=0;for(;e<t;)e++,this._poolPoints.push(new p)}get radius(){return this._radius}set radius(t){if(this._radius=Math.max(0,t),this._radiusSquared=this._radius*this._radius,this._sampleCircle=[],0==this._radius)return;let e,s=this._numSamplesCircle,i=0;for(;i<s;){let t=i++;e=-o*t/this._numSamplesCircle,this._sampleCircle.push(new p(this._radius*Math.cos(e),this._radius*Math.sin(e)))}this._sampleCircleDistanceSquared=E(this._sampleCircle[0].x-this._sampleCircle[1].x,this._sampleCircle[0].y-this._sampleCircle[1].y)}dispose(){this._sampleCircle=null}getPoint(t,e){return e=e||0,t=t||0,this.__point=this._poolPoints[this._currPoolPointsIndex],this.__point.set(t,e),this._currPoolPointsIndex++,this._currPoolPointsIndex==this._poolPointsSize&&(this._poolPoints.push(new p),this._poolPointsSize++),this.__point}getCopyPoint(t){return this.getPoint(t.x,t.y)}findPath(t,e,s,i,n){let h,r,o,a,l,d,p=t,c=e,x=1.01*this._radius;if(this._currPoolPointsIndex=0,this._radius>0){let t,e,i,n,h,r=s[0];i=r.edge.originVertex.pos,n=r.edge.destinationVertex.pos,h=r.edge.nextLeftEdge.destinationVertex.pos,t=E(i.x-p.x,i.y-p.y),t<=this._radiusSquared?(e=Math.sqrt(t),p.sub(i).div(e).mul(x).add(i)):(t=E(n.x-p.x,n.y-p.y),t<=this._radiusSquared?(e=Math.sqrt(t),p.sub(n).div(e).mul(x).add(n)):(t=E(h.x-p.x,h.y-p.y),t<=this._radiusSquared&&(e=Math.sqrt(t),p.sub(h).div(e).mul(x).add(h)))),r=s[s.length-1],i=r.edge.originVertex.pos,n=r.edge.destinationVertex.pos,h=r.edge.nextLeftEdge.destinationVertex.pos,t=E(i.x-c.x,i.y-c.y),t<=this._radiusSquared?(e=Math.sqrt(t),c.sub(i).div(e).mul(x).add(i)):(t=E(n.x-c.x,n.y-c.y),t<=this._radiusSquared?(e=Math.sqrt(t),c.sub(n).div(e).mul(x).add(n)):(t=E(h.x-c.x,h.y-c.y),t<=this._radiusSquared&&(e=Math.sqrt(t),c.sub(h).div(e).mul(x).add(h))))}if(h=p.clone(),r=c.clone(),1==s.length)return n.push(y(h.x)),n.push(y(h.y)),n.push(y(r.x)),void n.push(y(r.y));let f,_=null,m=null,w=D.isInFace(p,s[0]);1===w.type&&i[0]===w&&(i.length>1&&i.shift(),s.length>1&&s.shift(),g("!! isShift"));let C=[],S=[];C.push(h),S.push(h);let F=new u(1),V=[],P=new u(0),v=new u(0);P.set(h,0),_=i[0];let b,L,T,M=D.getRelativePosition2(p,_);L=this.getCopyPoint(_.destinationVertex.pos),T=this.getCopyPoint(_.originVertex.pos),V.push(L),V.push(T),v.set(h,L),v.set(L,T),b=T,1==M?(P.set(L,1),P.set(T,-1),F.set(_.destinationVertex,1),F.set(_.originVertex,-1)):-1==M&&(P.set(L,-1),P.set(T,1),F.set(_.destinationVertex,-1),F.set(_.originVertex,1));let N=i[0].originVertex,O=i[0].destinationVertex,R=1,k=i.length;for(;R<k;){_=i[R++],_.originVertex==N?m=_.destinationVertex:_.destinationVertex==N?m=_.originVertex:_.originVertex==O?(m=_.destinationVertex,N=O):_.destinationVertex==O?(m=_.originVertex,N=O):g("IMPOSSIBLE TO IDENTIFY THE VERTEX !!!"),L=this.getCopyPoint(m.pos),V.push(L),f=-F.get(N),P.set(L,f),v.set(b,L),F.set(m,f),b=L,O=N,N=m}v.set(b,r),P.set(r,0);let I,j=[],A=new u(1);j.push(h),A.set(h,0);let q=0,B=V.length;for(;q<B;){if(I=V[q++],-1==P.get(I)){for(a=C.length-2;a>=0;){if(f=D.getDirection(C[a],C[a+1],I),-1!=f){C.shift();let t=0;for(;t<a;)t++,j.push(C[0]),A.set(C[0],1),C.shift();j.push(C[0]),A.set(C[0],1),S.splice(0,S.length),S.push(C[0]),S.push(I);break}a--}for(S.push(I),a=S.length-3;a>=0&&(f=D.getDirection(S[a],S[a+1],I),-1!=f);)S.splice(a+1,1),a--}else{for(a=S.length-2;a>=0;){if(f=D.getDirection(S[a],S[a+1],I),1!=f){S.shift();let t=0;for(;t<a;)t++,j.push(S[0]),A.set(S[0],-1),S.shift();j.push(S[0]),A.set(S[0],-1),C.splice(0,C.length),C.push(S[0]),C.push(I);break}a--}for(C.push(I),a=C.length-3;a>=0&&(f=D.getDirection(C[a],C[a+1],I),1!=f);)C.splice(a+1,1),a--}}let W=!1;for(a=S.length-2;a>=0;){if(f=D.getDirection(S[a],S[a+1],c),1!=f){S.shift();let t=0,e=a+1;for(;t<e;)t++,j.push(S[0]),A.set(S[0],-1),S.shift();j.push(r),A.set(r,0),W=!0;break}a--}if(!W)for(a=C.length-2;a>=0;){if(f=D.getDirection(C[a],C[a+1],c),-1!=f){C.shift();let t=0,e=a+1;for(;t<e;)t++,j.push(C[0]),A.set(C[0],1),C.shift();j.push(r),A.set(r,0),W=!0;break}a--}W||(j.push(r),A.set(r,0),W=!0);let G=[];if(this._radius>0){let t=[];if(2==j.length)this.adjustWithTangents(j[0],!1,j[1],!1,P,v,t,G);else if(j.length>2){if(this.adjustWithTangents(j[0],!1,j[1],!0,P,v,t,G),j.length>3){let e=1,s=j.length-3+1;for(;e<s;){let s=e++;this.adjustWithTangents(j[s],!0,j[s+1],!0,P,v,t,G)}}let e=j.length;this.adjustWithTangents(j[e-2],!0,j[e-1],!1,P,v,t,G)}t.push(r),this.checkAdjustedPath(t,G,P);let e=[];for(o=t.length-2;o>=1;){for(this.smoothAngle(G[2*o-1],t[o],G[2*o],P.get(t[o]),e);0!=e.length;)G.splice(2*o,0,e.pop());o--}}else G=j;for(d=0,l=G.length;d<l;)o=d++,n.push(y(G[o].x)),n.push(y(G[o].y))}adjustWithTangents(t,e,s,i,n,h,r,o){let a=[],l=n.get(t),d=n.get(s),u=null,p=null;if(e||i)if(e)if(i)if(1==l&&1==d)D.tangentsParalCircleToCircle(this._radius,t,s,a),u=this.getPoint(a[2],a[3]),p=this.getPoint(a[4],a[5]);else if(-1==l&&-1==d)D.tangentsParalCircleToCircle(this._radius,t,s,a),u=this.getPoint(a[0],a[1]),p=this.getPoint(a[6],a[7]);else if(1==l&&-1==d){if(!D.tangentsCrossCircleToCircle(this._radius,t,s,a))return void g("NO TANGENT, points are too close for radius");u=this.getPoint(a[2],a[3]),p=this.getPoint(a[6],a[7])}else{if(!D.tangentsCrossCircleToCircle(this._radius,t,s,a))return void g("NO TANGENT, points are too close for radius");u=this.getPoint(a[0],a[1]),p=this.getPoint(a[4],a[5])}else{if(!D.tangentsPointToCircle(s,t,this._radius,a))return void g("NO TANGENT");a.length>0&&(1==l?(u=this.getPoint(a[0],a[1]),p=s):(u=this.getPoint(a[2],a[3]),p=s))}else{if(!D.tangentsPointToCircle(t,s,this._radius,a))return void g("NO TANGENT");1==d?(u=t,p=this.getPoint(a[2],a[3])):(u=t,p=this.getPoint(a[0],a[1]))}else u=t,p=s;let c,x=h.get(t);for(;x!=s;){if(c=D.distanceSquaredPointToSegment(x,u,p),c<this._radiusSquared)return this.adjustWithTangents(t,e,x,!0,n,h,r,o),void this.adjustWithTangents(x,!0,s,i,n,h,r,o);x=h.get(x)}o.push(u),o.push(p),r.push(t)}checkAdjustedPath(t,e,s){let i,n,h,r,o,a,l,d,g,u,p=!0,c=[],x=null,f=null;for(;p;){p=!1;let _=2;for(;_<t.length;)o=t[_],a=s.get(o),h=t[_-1],r=s.get(h),i=t[_-2],n=s.get(i),r==a&&(l=e[2*(_-2)],d=e[2*(_-1)-1],g=e[2*(_-1)],u=(l.x-d.x)*(g.x-d.x)+(l.y-d.y)*(g.y-d.y),u>0&&(2==_?(D.tangentsPointToCircle(i,o,this._radius,c),1==a?(x=i,f=this.getPoint(c[2],c[3])):(x=i,f=this.getPoint(c[0],c[1]))):_==t.length-1?(D.tangentsPointToCircle(o,i,this._radius,c),1==n?(x=this.getPoint(c[0],c[1]),f=o):(x=this.getPoint(c[2],c[3]),f=o)):1==n&&-1==a?(D.tangentsCrossCircleToCircle(this._radius,i,o,c),x=this.getPoint(c[2],c[3]),f=this.getPoint(c[6],c[7])):-1==n&&1==a?(D.tangentsCrossCircleToCircle(this._radius,i,o,c),x=this.getPoint(c[0],c[1]),f=this.getPoint(c[4],c[5])):1==n&&1==a?(D.tangentsParalCircleToCircle(this._radius,i,o,c),x=this.getPoint(c[2],c[3]),f=this.getPoint(c[4],c[5])):-1==n&&-1==a&&(D.tangentsParalCircleToCircle(this._radius,i,o,c),x=this.getPoint(c[0],c[1]),f=this.getPoint(c[6],c[7])),e.splice(2*(_-2),1,x),e.splice(2*_-1,1,f),t.splice(_-1,1),e.splice(2*(_-1)-1,2),c.splice(0,c.length),_--)),_++}}smoothAngle(t,e,s,i,n){let h=D.getDirection(t,e,s);if(E(t.x-s.x,t.y-s.y)<=this._sampleCircleDistanceSquared)return;let r,o,a,l,d=0,g=0,u=this._numSamplesCircle;for(;g<u;){let u=g++;a=!1,l=e.clone().add(this._sampleCircle[u]),r=D.getDirection(t,e,l),o=D.getDirection(e,s,l),1==i?-1==h?-1==r&&-1==o&&(a=!0):-1!=r&&-1!=o||(a=!0):1==h?1==r&&1==o&&(a=!0):1!=r&&1!=o||(a=!0),a?(n.splice(d,0,l),d++):d=0}-1==i&&n.reverse()}}class Y{constructor(){this.astar=new G,this.funnel=new X,this.listFaces=[],this.listEdges=[],this._mesh=null,this.entity=null}get mesh(){return this._mesh}set mesh(t){this._mesh=t,this.astar.mesh=t}dispose(){this._mesh=null,this.astar.dispose(),this.astar=null,this.funnel.dispose(),this.funnel=null,this.listEdges=null,this.listFaces=null}findPath(t,e){if(e.splice(0,e.length),D.isCircleIntersectingAnyConstraint(t,this.entity.radius,this._mesh))return;this.astar.radius=this.entity.radius,this.funnel.radius=this.entity.radius,this.listFaces.splice(0,this.listFaces.length),this.listEdges.splice(0,this.listEdges.length);let s=this.entity.position;this.astar.findPath(s,t,this.listFaces,this.listEdges),0!=this.listFaces.length?this.funnel.findPath(s,t,this.listFaces,this.listEdges,e):g("PATH LENGTH = 0 (PathFinder)")}}class H{constructor(){this.entity=null,this._path=null,this._samplingDistanceSquared=1,this._samplingDistance=1,this._preCompX=[],this._preCompY=[],this.pos=new p,this.hasPrev=!1,this.hasNext=!1,this._count=0}get x(){return this.pos.x}get y(){return this.pos.y}get countMax(){return this._preCompX.length-1}get count(){return this._count}set count(t){this._count=t,this._count<0&&(this._count=0),this._count>this.countMax-1&&(this._count=this.countMax-1),0==this._count?this.hasPrev=!1:this.hasPrev=!0,this._count==this.countMax-1?this.hasNext=!1:this.hasNext=!0,this.applyLast(),this.updateEntity()}get samplingDistance(){return this._samplingDistance}set samplingDistance(t){this._samplingDistance=t,this._samplingDistanceSquared=this._samplingDistance*this._samplingDistance}get path(){return this._path}set path(t){this._path=t,this._preComputed=!1,this.reset()}dispose(){this.entity=null,this._path=null,this._preCompX=null,this._preCompY=null}reset(){this._path.length>0?(this.pos.x=this._path[0],this.pos.y=this._path[1],this._iPrev=0,this._iNext=2,this.hasPrev=!1,this.hasNext=!0,this._count=0,this.updateEntity()):(this.hasPrev=!1,this.hasNext=!1,this._count=0)}preCompute(){for(this._preCompX.splice(0,this._preCompX.length),this._preCompY.splice(0,this._preCompY.length),this._count=0,this._preCompX.push(this.pos.x),this._preCompY.push(this.pos.y),this._preComputed=!1;this.next();)this._preCompX.push(this.pos.x),this._preCompY.push(this.pos.y);this.reset(),this._preComputed=!0}prev(){if(!this.hasPrev)return!1;if(this.hasNext=!0,this._preComputed)return this._count--,0==this._count&&(this.hasPrev=!1),this.applyLast(),this.updateEntity(),!0;let t,e;for(t=this._samplingDistance;;){let s=this._path[this._iPrev],i=this._path[this._iPrev+1];if(e=_(this.pos.x-s,this.pos.y-i),!(e<t))break;if(t-=e,this._iPrev-=2,this._iNext-=2,0==this._iNext)break}return 0==this._iNext?(this.pos.x=this._path[0],this.pos.y=this._path[1],this.hasPrev=!1,this._iNext=2,this._iPrev=0,this.updateEntity(),!0):(this.pos.x=this.pos.x+(this._path[this._iPrev]-this.pos.x)*t/e,this.pos.y=this.pos.y+(this._path[this._iPrev+1]-this.pos.y)*t/e,this.updateEntity(),!0)}next(){if(!this.hasNext)return!1;if(this.hasPrev=!0,this._preComputed)return this._count++,this._count==this._preCompX.length-1&&(this.hasNext=!1),this.applyLast(),this.updateEntity(),!0;let t,e;for(t=this._samplingDistance;;){let s=this._path[this._iNext],i=this._path[this._iNext+1];if(e=_(this.pos.x-s,this.pos.y-i),!(e<t))break;if(t-=e,this.pos.x=this._path[this._iNext],this.pos.y=this._path[this._iNext+1],this._iPrev+=2,this._iNext+=2,this._iNext==this._path.length)break}return this._iNext==this._path.length?(this.pos.x=this._path[this._iPrev],this.pos.y=this._path[this._iPrev+1],this.hasNext=!1,this._iNext=this._path.length-2,this._iPrev=this._iNext-2,this.updateEntity(),!0):(this.pos.x=this.pos.x+(this._path[this._iNext]-this.pos.x)*t/e,this.pos.y=this.pos.y+(this._path[this._iNext+1]-this.pos.y)*t/e,this.updateEntity(),!0)}applyLast(){this.pos.set(this._preCompX[this._count],this._preCompY[this._count])}updateEntity(){null!==this.entity&&(this.entity.distance=this.entity.position.distanceTo(this.pos),this.entity.distance>.01&&(this.entity.angle=this.entity.position.angleTo(this.pos)),this.entity.direction.angular(this.entity.angle).mul(this.entity.distance),this.entity.position.copy(this.pos))}}class U{constructor(t,e){this.entity=t||null,this.world=e||null}isInField(t){if(!this.world)return;if(!this.entity)return;this.mesh=this.world.getMesh();let e=this.entity.position,s=this.entity.direction,i=t.position,h=this.entity.radiusFOV,r=this.entity.angleFOV,o=t.radius;if(E(e.x-i.x,e.y-i.y)>=(h+o)*(h+o))return!1;let a,l,d=new p,g=new p,c=[];D.intersections2Circles(e,h,i,o,c)&&(d.set(c[0],c[1]),g.set(c[2],c[3]));let x=e.clone().add(i).mul(.5);(0==c.length||E(x.x-i.x,x.y-i.y)<E(x.x-d.x,x.y-d.y))&&(c.splice(0,c.length),D.tangentsPointToCircle(e,i,o,c),d.set(c[0],c[1]),g.set(c[2],c[3]));let f=Math.cos(.5*this.entity.angleFOV),_=d.clone().sub(e),m=Math.sqrt(_.x*_.x+_.y*_.y);a=_.x/m*s.x+_.y/m*s.y>f;let y=g.clone().sub(e),w=Math.sqrt(y.x*y.x+y.y*y.y);if(l=y.x/w*s.x+y.y/w*s.y>f,!a&&!l){let t=e.clone().add(s);if(1!==D.getDirection(e,t,d)||-1!==D.getDirection(e,t,g))return!1}if(!a||!l){let t,i=new p;if(t=Math.atan2(s.y,s.x),!a){let s=new p(Math.cos(t-.5*r),Math.sin(t-.5*r)).add(e);D.intersections2segments(e,s,d,g,i,null,!0),d=i.clone()}if(!l){let s=new p(Math.cos(t+.5*r),Math.sin(t+.5*r)).add(e);D.intersections2segments(e,s,d,g,i,null,!0),g=i.clone()}}let C,S=new u(0),F=new u(0),V=[],P=D.locatePosition(e,this.mesh);2==P.type?C=P:1==P.type?C=P.leftFace:0==P.type&&(C=P.edge.leftFace);let v,b,L,T,M=[],N=new u(0);M.push(C),N[C]=!0;let O,R,k,I,j,A=new p,q=new p,B=[],W=[];for(;M.length>0;)for(v=M.shift(),N.set(v,null),S.set(v,!0),b=v.edge,F.get(b)||F.get(b.oppositeEdge)||(W.push(b),F.set(b,!0)),b=b.nextLeftEdge,F.get(b)||F.get(b.oppositeEdge)||(W.push(b),F.set(b,!0)),b=b.nextLeftEdge,F.get(b)||F.get(b.oppositeEdge)||(W.push(b),F.set(b,!0));W.length>0;)if(b=W.pop(),L=b.originVertex.pos,T=b.destinationVertex.pos,D.clipSegmentByTriangle(L,T,e,g,d,A,q)){if(b.isConstrained){for(B.splice(0,B.length),D.intersections2segments(e,A,d,g,null,B,!0),D.intersections2segments(e,q,d,g,null,B,!0),O=B[1],R=B[3],R<O&&(O=R,R=B[1]),k=V.length-1;k>=0&&!(R>=V[k]);k--);for(j=k+1,j%2==0&&V.splice(j,0,R),k=0;k<V.length&&!(O<=V[k]);k++);if(I=k,I%2==0?(V.splice(I,0,O),j++):I--,V.splice(I+1,j-I-1),2==V.length&&-.01<V[0]&&V[0]<n&&.99<V[1]&&V[1]<1.01)return!1}v=b.rightFace,N.get(v)||S.get(v)||(M.push(v),N.set(v,!0))}return!0}}class K{constructor(t={},e){this.isSee=!1,this.isWalking=!1,this.isSelected=!1,this.isMove=!1,this.isTurn=!1,this.isActive=!1,this.world=e,this.turnSpeed=t.turn||0,this.turnStep=0,this.needTurn=!1,this.step=0,this.color={r:255,g:255,b:255,a:.75},this.color2={r:0,g:0,b:255,a:.75},this.position=new p(t.x||0,t.y||0),this.direction=new p(1,0),this.distance=0,this.radius=t.r||10,this.angle=t.angle||0,this.angleNext=0,this.angleFOV=(t.fov||120)*s,this.radiusFOV=t.distance||200,this.testSee=t.see||!1,this.angledelta=0,this.turnStep=0,this.needTurn=!1,this.path=[],this.tmppath=[],this.target=new p,this.newPath=!1,this.mesh=null,this.fov=new U(this,this.world),this.pathSampler=new H,this.pathSampler.entity=this,this.pathSampler.path=this.tmppath,this.pathSampler.samplingDistance=t.speed||10}clearTarget(){this.pathSampler.hasNext&&(this.pathSampler.hasPrev=!1,this.pathSampler.hasNext=!1,this.pathSampler._count=0),this.isActive=!1}setAngle(t){this.angle=f(t)}setTarget(t,e,s){return this.path=[],this.target.set(t,e),this.world.pathFinder.entity=this,this.world.pathFinder.findPath(this.target,this.path),this.testPath(s)}testPath(t){if(!this.path)return!1;if(this.path.length>0){const e=void 0!==t?f(t):this.angle;if(this.pathSampler.reset(),this.tmppath=[...this.path],this.pathSampler.path=this.tmppath,this.newPath=!0,this.step=0,this.turnStep=0,0!==this.turnSpeed&&this.tmppath.length>=4){this.angleNext=this.position.angleTo({x:this.tmppath[2],y:this.tmppath[3]});let t=this.getNear(this.angleNext,e);this.turnStep=Math.floor(Math.abs(Math.round(t*i))/this.turnSpeed),this.angledelta=t/this.turnStep,this.needTurn=!0,this.step=0,(this.angledelta===1/0||this.angledelta===-1/0||isNaN(this.angledelta))&&(this.angledelta=0,this.turnStep=0,this.needTurn=!1)}return!0}}getNear(t,e){return Math.atan2(Math.sin(t-e),Math.cos(t-e))}getPos(){return{x:this.position.x,y:this.position.y,r:-this.angle}}update(){var t;this.pathSampler.hasNext?this.needTurn?(this.isTurn=!0,this.step++,this.angle+=this.angledelta,this.step===this.turnStep&&(this.needTurn=!1)):(this.newPath=!1,this.isMove=!0,this.isTurn=!1,this.pathSampler.next()):(this.isMove=!1,this.isTurn=!1,this.tmppath=[]),this.isActive=!(!this.isMove&&!this.isTurn),this.isMove&&!this.isWalking&&(this.isWalking=!0),!this.isMove&&this.isWalking&&(this.isWalking=!1),null!==this.mesh&&(t=this.getPos(),this.mesh.position.set(t.x,0,t.y),this.mesh.rotation.y=t.r-.5*Math.PI)}}class z extends W{constructor(t=10,e=10){super(t,e);const s=[],i=[],n=[],h=[];let r=4;for(;r--;)n.push(new T),s.push(new M),h.push(new O),i.push(new L,new L,new L);const o=new N,a=10;s[0].pos.set(-10,-10),s[1].pos.set(t+a,-10),s[2].pos.set(t+a,e+a),s[3].pos.set(-10,e+a),s[0].setDatas(i[0]),s[1].setDatas(i[2]),s[2].setDatas(i[4]),s[3].setDatas(i[6]),i[0].setDatas(s[0],i[1],i[2],n[3],!0,!0),i[1].setDatas(s[1],i[0],i[7],n[0],!0,!0),i[2].setDatas(s[1],i[3],i[11],n[3],!0,!0),i[3].setDatas(s[2],i[2],i[8],n[1],!0,!0),i[4].setDatas(s[2],i[5],i[6],n[2],!0,!0),i[5].setDatas(s[3],i[4],i[3],n[1],!0,!0),i[6].setDatas(s[3],i[7],i[10],n[2],!0,!0),i[7].setDatas(s[0],i[6],i[9],n[0],!0,!0),i[8].setDatas(s[1],i[9],i[5],n[1],!0,!1),i[9].setDatas(s[3],i[8],i[1],n[0],!0,!1),i[10].setDatas(s[0],i[11],i[4],n[2],!1,!1),i[11].setDatas(s[2],i[10],i[0],n[3],!1,!1),n[0].setDatas(i[9],!0),n[1].setDatas(i[8],!0),n[2].setDatas(i[4],!1),n[3].setDatas(i[2],!1),s[0].fromConstraintSegments.push(h[0],h[3]),s[1].fromConstraintSegments.push(h[0],h[1]),s[2].fromConstraintSegments.push(h[1],h[2]),s[3].fromConstraintSegments.push(h[2],h[3]),i[0].fromConstraintSegments.push(h[0]),i[1].fromConstraintSegments.push(h[0]),i[2].fromConstraintSegments.push(h[1]),i[3].fromConstraintSegments.push(h[1]),i[4].fromConstraintSegments.push(h[2]),i[5].fromConstraintSegments.push(h[2]),i[6].fromConstraintSegments.push(h[3]),i[7].fromConstraintSegments.push(h[3]),h[0].edges.push(i[0]),h[1].edges.push(i[2]),h[2].edges.push(i[4]),h[3].edges.push(i[6]),h[0].fromShape=o,h[1].fromShape=o,h[2].fromShape=o,h[3].fromShape=o,o.segments.push(h[0],h[1],h[2],h[3]),this._vertices=s,this._edges=i,this._faces=n,this._constraintShapes.push(o),this.clipping=!1,this.insertConstraintShape([0,0,t,0,t,0,t,e,t,e,0,e,0,e,0,0]),this.clipping=!0}}const Z=(t,e=1)=>{e=e||1;let s=t.length;if(s<=4)return[].concat(t);let i=t[0],n=t[1],h=t[s-2],r=t[s-1],o=-1,a=0,l=1,d=s>>1;for(;l<d;){let e=l++,s=D.distanceSquaredPointToSegment(new p(t[e<<1],t[1+(e<<1)]),new p(i,n),new p(h,r));s>a&&(a=s,o=e)}if(a>e*e){let s=t.slice(0,2+(o<<1)),i=t.slice(o<<1),n=Z(s,e),h=Z(i,e);return n.slice(0,n.length-2).concat(h)}return[i,n,h,r]};class Q{static buildFromBmpData(t,e=1,s){void 0!==s&&B.setColor(s);let i=(e=e||1)>=1;const n=B.buildShapes(t);let h,r,o=n.length,a=0,l=0;const d=new z(t.width,t.height);for(;o--;){for(i&&(n[a]=Z(n[a],e)),r=B.buildPolygon(B.buildGraph(n[a])),h=.5*(r.length-2),l=0;h--;)d.insertConstraintSegment(r[l],r[l+1],r[l+2],r[l+3]),l+=2;d.insertConstraintSegment(r[0],r[1],r[l],r[l+1]),a++}return d}}class J{static buildFromBmpData(t,e=1,s){void 0!==s&&B.setColor(s);let i=(e=e||1)>=1;const n=B.buildShapes(t);let h,r,o=n.length,a=0,l=0;const d=new R;for(;o--;){for(i&&(n[a]=Z(n[a],e)),r=B.buildPolygon(B.buildGraph(n[a])),h=.5*(r.length-2),l=0;h--;)d.coordinates.push(r[l],r[l+1],r[l+2],r[l+3]),l+=2;d.coordinates.push(r[0],r[1],r[l],r[l+1]),a++}return d}}function $(t,e){this.visited=!1,this.col=t,this.row=e;let s=[],i=0;for(;i<4;)i++,s.push([]);this.walls=s}class tt{constructor(t,e,s,i){this.w=t||200,this.h=e||200,this.canvas=document.createElement("canvas"),this.canvas.width=this.w,this.canvas.height=this.h,this.ctx=this.canvas.getContext("2d"),this.canvas.style.cssText=i||"position:absolute; left:50%; top:50%; margin-left:"+.5*-this.w+"px; margin-top:"+.5*-this.h+"px;",void 0===s&&(s=document.body),s.appendChild(this.canvas)}clear(){this.ctx.clearRect(0,0,this.w,this.h)}drawImage(t,e,s){this.ctx.drawImage(t,0,0,e||this.w,s||this.h)}drawCircle(t,e,s,i,n){i=i||0,n=n||o,this.ctx.beginPath(),this.ctx.arc(t,e,s,i,n,!1)}drawRect(t,e,s,i){this.ctx.beginPath(),this.ctx.moveTo(t,e),this.ctx.lineTo(t+s,e),this.ctx.lineTo(t+s,e+i),this.ctx.lineTo(t,e+i),this.ctx.stroke(),this.ctx.closePath()}lineStyle(t,e){this.ctx.lineWidth=t,this.ctx.strokeStyle="rgba("+e.r+","+e.g+","+e.b+","+e.a+")"}moveTo(t,e){this.ctx.beginPath(),this.ctx.moveTo(t,e)}lineTo(t,e){this.ctx.lineTo(t,e)}stroke(){this.ctx.stroke()}closePath(){this.ctx.closePath()}beginFill(t){this.ctx.fillStyle="rgba("+t.r+","+t.g+","+t.b+","+t.a+")",this.ctx.beginPath()}endFill(){this.ctx.closePath(),this.ctx.fill()}}function et(t,e,s){let i=s;this.world=e,this.maxVertices=3e4,this.currentVertex=0;let n=new i.BufferGeometry;n.addAttribute("position",new i.BufferAttribute(new Float32Array(3*this.maxVertices),3)),n.addAttribute("color",new i.BufferAttribute(new Float32Array(3*this.maxVertices),3)),this.positions=n.attributes.position.array,this.colors=n.attributes.color.array,n.computeBoundingSphere(),this.buffer=new i.LineSegments(n,new i.LineBasicMaterial({vertexColors:!0})),this.buffer.frustumCulled=!1,t.add(this.buffer),this.maxPathVertices=1e3,this.currentPathVertex=0;let h=new i.BufferGeometry;h.addAttribute("position",new i.BufferAttribute(new Float32Array(3*this.maxPathVertices),3)),h.addAttribute("color",new i.BufferAttribute(new Float32Array(3*this.maxPathVertices),3)),this.positionsPath=h.attributes.position.array,this.colorsPath=h.attributes.color.array,n.computeBoundingSphere(),this.bufferPath=new i.LineSegments(h,new i.LineBasicMaterial({vertexColors:!0})),this.bufferPath.frustumCulled=!1,t.add(this.bufferPath),a.set(this)}et.prototype={constructor:et,drawMesh:function(t,e){},collapseBuffer:function(){let t=this.maxVertices,e=this.currentVertex,s=0;for(;t>=e;)s=3*t,this.positions[s]=0,this.positions[s+1]=0,this.positions[s+2]=0,this.colors[s]=0,this.colors[s+1]=0,this.colors[s+2]=0,t--},collapsePathBuffer:function(){let t=this.maxPathVertices,e=this.currentPathVertex,s=0;for(;t>=e;)s=3*t,this.positionsPath[s]=0,this.positionsPath[s+1]=0,this.positionsPath[s+2]=0,this.colorsPath[s]=0,this.colorsPath[s+1]=0,this.colorsPath[s+2]=0,t--},update:function(){this.world.mesh.isRedraw&&(this.currentVertex=0,this.world.mesh.draw(),this.collapseBuffer(),this.buffer.geometry.attributes.position.needsUpdate=!0,this.buffer.geometry.attributes.color.needsUpdate=!0),this.world.update();let t,e=this.world.heroes.length;for(;e--;)if(t=this.world.heroes[e],t.isSelected&&t.tmppath.length>0){this.currentPathVertex=0;let t=this.world.heroes[e].tmppath,s=t[0],i=t[1],n=2;for(;n<t.length;)this.insertPath(s,i,t[n],t[n+1],1,0,0),s=t[n],i=t[n+1],n+=2;this.collapsePathBuffer(),this.bufferPath.geometry.attributes.position.needsUpdate=!0,this.bufferPath.geometry.attributes.color.needsUpdate=!0}},insertLine:function(t,e,s,i,n,h,r){let o=this.currentVertex,a=3*o;this.positions[a]=t,this.positions[a+1]=0,this.positions[a+2]=e,this.colors[a]=n,this.colors[a+1]=h,this.colors[a+2]=r,o++,a=3*o,this.positions[a]=s,this.positions[a+1]=0,this.positions[a+2]=i,this.colors[a]=n,this.colors[a+1]=h,this.colors[a+2]=r,this.currentVertex+=2},insertPath:function(t,e,s,i,n,h,r){let o=this.currentPathVertex,a=3*o;this.positionsPath[a]=t,this.positionsPath[a+1]=0,this.positionsPath[a+2]=e,this.colorsPath[a]=n,this.colorsPath[a+1]=h,this.colorsPath[a+2]=r,o++,a=3*o,this.positionsPath[a]=s,this.positionsPath[a+1]=0,this.positionsPath[a+2]=i,this.colorsPath[a]=n,this.colorsPath[a+1]=h,this.colorsPath[a+2]=r,this.currentPathVertex+=2}},W.prototype.draw=function(){this.compute_Data();let t=a.get(),e=this.AR_edge,s=e.length,i=0;for(;s--;)i=5*s,e[i+4]?t.insertLine(e[i],e[i+1],e[i+2],e[i+3],0,0,0):t.insertLine(e[i],e[i+1],e[i+2],e[i+3],.4,.4,.4);this.isRedraw=!1},t.AStar=G,t.BitmapMesh=Q,t.BitmapObject=J,t.CircleMesh=class{constructor(t=100,e=100,s=100,i=8){let n=[],h=[],r=[],a=[],l=[],d=i;for(;d--;)r.push(new T),n.push(new M),a.push(new O),h.push(new L,new L,new L);let g=new N,u=1/i;for(d=0;d<i;)n[d].pos.set(t+(s+10)*Math.cos(o*d*u),e+(s+10)*Math.sin(o*d*u)),n[d].setDatas(h[2*d]),d++;for(d=0;d<i;)l.push(t+s*Math.cos(o*d*u)),l.push(e+s*Math.sin(o*d*u)),l.push(t+s*Math.cos(o*(d+1)*u)),l.push(e+s*Math.sin(o*(d+1)*u)),d++;let p=new W(2*s,2*s);return p._vertices=n,p._edges=h,p._faces=r,p._constraintShapes.push(g),p.clipping=!1,p.insertConstraintShape(l),p.clipping=!0,p}},t.Debug=d,t.Dictionary=u,t.Dungeon=class{constructor(t,e,s,i){this.generate(t,e,s,i)}generate(t,e,s,i){let n,h,r;for(this.w=t/10,this.h=e/10,this.rooms=[],this.map=[],h=0;h<this.w;h++)for(this.map[h]=[],r=0;r<this.h;r++)this.map[h][r]=0;let o=x(10,20),a=s||5,l=i||15;for(n=0;n<o;n++){let t={};t.x=x(1,this.w-l-1),t.y=x(1,this.h-l-1),t.w=x(a,l),t.h=x(a,l),this.DoesCollide(t)?n--:(t.w--,t.h--,this.rooms.push(t))}for(this.SquashRooms(),n=0;n<o;n++){let t=this.rooms[n],e=this.FindClosestRoom(t),s={x:x(t.x,t.x+t.w),y:x(t.y,t.y+t.h)},i={x:x(e.x,e.x+e.w),y:x(e.y,e.y+e.h)};for(;i.x!=s.x||i.y!=s.y;)i.x!=s.x?i.x>s.x?i.x--:i.x++:i.y!=s.y&&(i.y>s.y?i.y--:i.y++),this.map[i.x][i.y]=1}for(n=0;n<o;n++){let t=this.rooms[n];for(let e=t.x;e<t.x+t.w;e++)for(let s=t.y;s<t.y+t.h;s++)this.map[e][s]=1}for(h=0;h<this.w;h++)for(r=0;r<this.h;r++)if(1==this.map[h][r])for(let t=h-1;t<=h+1;t++)for(let e=r-1;e<=r+1;e++)0==this.map[t][e]&&(this.map[t][e]=2);this.populateObject()}FindClosestRoom(t){let e=t.x+t.w/2,s=t.y+t.h/2,i=null,n=1e3;for(let h=0;h<this.rooms.length;h++){let r=this.rooms[h];if(r==t)continue;let o={x:r.x+r.w/2,y:r.y+r.h/2},a=Math.min(Math.abs(e-o.x)-t.w/2-r.w/2,Math.abs(s-o.y)-t.h/2-r.h/2);a<n&&(n=a,i=r)}return i}SquashRooms(){for(let t=0;t<10;t++)for(let t=0;t<this.rooms.length;t++){let e=this.rooms[t];for(;;){let s={x:e.x,y:e.y};if(e.x>1&&e.x--,e.y>1&&e.y--,1==e.x&&1==e.y)break;if(this.DoesCollide(e,t)){e.x=s.x,e.y=s.y;break}}}}DoesCollide(t,e){for(let s=0;s<this.rooms.length;s++){if(s==e)continue;let i=this.rooms[s];if(!(t.x+t.w<i.x||t.x>i.x+i.w||t.y+t.h<i.y||t.y>i.y+i.h))return!0}return!1}populateObject(){let t=document.createElement("canvas");t.width=10*this.w,t.height=10*this.h;let e=t.getContext("2d");e.fillStyle="#FFF",e.fillRect(0,0,t.width,t.height);for(let t=0;t<this.h;t++)for(let s=0;s<this.w;s++){let i=this.map[s][t];e.fillStyle=0===i?"#000000":1===i?"#FFFFFF":"#000000",e.fillRect(10*s,10*t,10,10)}let s=C(null,e.getImageData(0,0,10*this.w,10*this.h),10*this.w,10*this.h);this.object=J.buildFromBmpData(s,1.8)}},t.EDGE=1,t.EPSILON_NORMAL=n,t.EPSILON_SQUARED=h,t.Edge=L,t.Entity=K,t.FACE=2,t.Face=T,t.FieldOfView=U,t.Funnel=X,t.Geom2D=D,t.Graph=k,t.GridMaze=class{constructor(t,e,s,i){this.generate(t,e,s,i)}generate(t,e,s,i){this.tileWidth=t/s|0,this.tileHeight=e/i|0,this.cols=s,this.rows=i,this.rng=new S(x(1234,7259)),this.makeGrid(),this.traverseGrid(),this.populateObject()}makeGrid(){this.grid=[];let t=0,e=this.cols;for(;t<e;){let e=t++;this.grid[e]=[];let s=0,i=this.rows;for(;s<i;){let t=s++,i=new $(e,t);this.grid[e][t]=i;let n=[e*this.tileWidth,t*this.tileHeight],h=[(e+1)*this.tileWidth,t*this.tileHeight],r=[e*this.tileWidth,(t+1)*this.tileHeight],o=[(e+1)*this.tileWidth,(t+1)*this.tileHeight];i.walls[0]=n.concat(h),i.walls[1]=h.concat(o),i.walls[2]=r.concat(o),0==t&&0==e||(i.walls[3]=n.concat(r))}}}traverseGrid(){let t=[0,1,0,-1],e=[-1,0,1,0],s=[2,3,0,1],i=this.rng.nextInRange(0,this.cols-1),n=this.rng.nextInRange(0,this.rows-1),h=[this.grid[i][n]];for(;h.length>0;){let i=h.length-1,n=h[i];n.visited=!0;let r=[0,1,2,3];this.rng.shuffle(r);let o=0;for(;o<r.length;){let a=r[o];++o;let l=n.col+t[a],d=n.row+e[a];if(l>=0&&l<this.cols&&d>=0&&d<this.rows&&!this.grid[l][d].visited){let t=this.grid[l][d];n.walls[a]=[],t.walls[s[a]]=[],t.visited=!0,h.push(t),i=-1;break}}i>=0&&h.splice(i,1)}}populateObject(){this.object=new R;let t=[],e=0,s=this.cols;for(;e<s;){let s=e++,i=0,n=this.rows;for(;i<n;){let e=i++,n=0,h=this.grid[s][e].walls;for(;n<h.length;){let e=h[n];++n;let s=0;for(;s<e.length;){let i=e[s];++s,t.push(i)}}}}this.object.coordinates=t}},t.IDX=l,t.INFINITY=r,t.Integral=w,t.LinearPathSampler=H,t.Log=g,t.Main=a,t.Matrix2D=c,t.Mesh2D=W,t.NULL=3,t.Object2D=R,t.PathFinder=Y,t.PathIterator=class{constructor(){this.entity=null,this.hasPrev=!1,this.hasNext=!1,this.countMax=0,this.count=0,this._currentX=0,this._currentY=0,this._path=[]}get x(){return this._currentX}get y(){return this._currentY}get path(){return this._path}set path(t){this._path=t,this.countMax=.5*this._path.length,this.reset()}reset(){this.count=0,this._currentX=this._path[this.count],this._currentY=this._path[this.count+1],this.updateEntity(),this.hasPrev=!1,this._path.length>2?this.hasNext=!0:this.hasNext=!1}prev(){return!!this.hasPrev&&(this.hasNext=!0,this.count--,this._currentX=this._path[2*this.count],this._currentY=this._path[2*this.count+1],this.updateEntity(),0==this.count&&(this.hasPrev=!1),!0)}next(){return!!this.hasNext&&(this.hasPrev=!0,this.count++,this._currentX=this._path[2*this.count],this._currentY=this._path[2*this.count+1],this.updateEntity(),2*(this.count+1)==this._path.length&&(this.hasNext=!1),!0)}updateEntity(){this.entity&&(this.entity.x=this._currentX,this.entity.y=this._currentY)}},t.Point=p,t.Potrace=B,t.REVISION="1.0.0",t.RectMesh=z,t.Segment=O,t.Shape=N,t.SimpleView=class{constructor(t,e,s){this.g0=new tt(t.w,t.h,e,s),this.g=new tt(t.w,t.h,e,s),this.g.canvas.style.pointerEvents="none",this.g0.canvas.style.pointerEvents="auto",this.entitiesWidth=2,this.entitiesColor={r:0,g:0,b:255,a:.75},this.entitiesColor2={r:255,g:255,b:255,a:.75},this.entitiesField={r:0,g:0,b:255,a:.1},this.entitiesField2={r:255,g:255,b:255,a:.1},this.pathsWidth=2,this.pathsColor={r:255,g:255,b:0,a:.75},this.verticesRadius=1,this.verticesColor={r:255,g:120,b:0,a:.5},this.constraintsWidth=2,this.constraintsColor={r:0,g:255,b:0,a:1},this.edgesWidth=1,this.edgesColor={r:190,g:190,b:190,a:.25},this.edgesColor2={r:0,g:190,b:0,a:.25},this.mesh_data=null,this.domElement=this.g0.canvas,this.extraEdge=function(t,e){},a.set(this)}drawImage(t,e,s){this.g0.drawImage(t,e,s)}drawMesh(t,e){let s=this.g0;void 0!==e&&e&&this.g0.clear(),t.compute_Data();let i=t.AR_edge,n=t.AR_vertex,h=i.length,r=0;for(;h--;)r=5*h,i[r+4]?(s.lineStyle(this.constraintsWidth,this.constraintsColor),this.extraEdge([i[r],i[r+1]],[i[r+2],i[r+3]])):s.lineStyle(this.edgesWidth,this.edgesColor),s.moveTo(i[r],i[r+1]),s.lineTo(i[r+2],i[r+3]),s.stroke(),s.closePath();for(s.lineStyle(this.verticesRadius,this.verticesColor),h=n.length;h--;)r=2*h,s.beginFill(this.verticesColor,this.verticesAlpha),s.drawCircle(n[r],n[r+1],this.verticesRadius),s.endFill()}drawEntity(t,e){let s=this.g,i=t.isSee;void 0!==e&&e&&s.clear(),i?s.beginFill(this.entitiesField):s.beginFill(this.entitiesField2),s.moveTo(t.position.x,t.position.y),s.drawCircle(t.position.x,t.position.y,t.radiusFOV,t.angle-.5*t.angleFOV,t.angle+.5*t.angleFOV),s.lineTo(t.position.x,t.position.y),s.endFill(),s.beginFill(i?t.color2:t.color),s.lineStyle(this.entitiesWidth,this.entitiesColor2),s.drawCircle(t.position.x,t.position.y,t.radius),s.stroke(),s.endFill()}drawPath(t,e){let s=this.g;if(void 0!==e&&e&&this.g.clear(),0===t.length)return;s.lineStyle(this.pathsWidth,this.pathsColor),s.moveTo(t[0],t[1]);let i=2;for(;i<t.length;)s.lineTo(t[i],t[i+1]),i+=2;s.stroke()}clear(){this.g.clear()}},t.Squared=E,t.SquaredSqrt=_,t.TTIER=e,t.ThreeView=et,t.TwoPI=o,t.VERTEX=0,t.Vertex=M,t.World=class{constructor(t=512,e=512){l.reset(),this.heroes=[],this.shapes=[],this.segments=[],this.objects=[],this.w=t,this.h=e,this.mesh=new z(this.w,this.h),this.pathFinder=new Y,this.pathFinder.mesh=this.mesh}getMesh(){return this.mesh}update(){let t,e,s=this.heroes.length,i=s;for(;i--;)if(e=this.heroes[i],e.update(),e.testSee)for(t=s;t--;)i!==t&&(this.heroes[i].isSee=this.heroes[i].fov.isInField(this.heroes[t]))}updateMesh(){this.mesh.updateObjects()}add(t){this.mesh.insertObject(t),this.objects.push(t)}addHeroe(t){let e=new K(t,this);return this.heroes.push(e),e}addObject(t){t=t||{};let e=new R;return e.coordinates=t.coord||[-1,-1,1,-1,1,-1,1,1,1,1,-1,1,-1,1,-1,-1],e.position(t.x||1,t.y||1),e.scale(t.w||1,t.h||1),e.pivot(t.px||0,t.py||0),e.rotation=t.r||0,this.mesh.insertObject(e),this.objects.push(e),e}reset(t,e){this.mesh.dispose(),t&&(this.w=t),e&&(this.h=e),this.mesh=new z(this.w,this.h),this.pathFinder.mesh=this.mesh}rebuild(t){this.mesh.clear(!0),this.mesh=void 0!==t?t:new z(this.w,this.h),this.pathFinder.mesh=this.mesh;let e=this.objects.length;for(;e--;)this.objects[e]._constraintShape=null,this.mesh.insertObject(this.objects[e])}addBitmapZone(t={}){if(t.url){let e=document.createElement("img");e.onload=function(){t.pixel=C(e),this.updateBitmapZone(t)}.bind(this),e.src=t.url}if(t.canvas){let e=t.canvas.width,s=t.canvas.height;t.pixel=C(null,t.canvas.getContext("2d").getImageData(0,0,e,s),e,s),this.updateBitmapZone(t)}t.img&&(t.pixel=C(t.img),this.updateBitmapZone(t))}updateBitmapZone(t={}){this.mesh.dispose(),this.mesh=Q.buildFromBmpData(t.pixel,t.precision,t.color),this.pathFinder.mesh=this.mesh;let e=a.get();e&&e.drawMesh(this.mesh)}},t.fix=y,t.fromImageData=C,t.nearEqual=m,t.rand=(t,e)=>t+Math.random()*(e-t),t.randInt=x,t.todeg=i,t.torad=s,t.unwrap=f,Object.defineProperty(t,"__esModule",{value:!0})}));
